<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Brainfuck Interpreter">
    <title>Brainfuck Interpreter</title>
    <style>
      html {
          font-family: "Consolas", "MS Gothic", monospace;
          font-size: 20px;
          overscroll-behavior: none;
          text-size-adjust: 100%;
          -webkit-text-size-adjust: 100%;
      }
      *, *::before, *::after {
          font-family: inherit;
          font-size: 100%;
      }
      body {
          background-color: rgb(200, 200, 200);
      }

      .area {
          margin: 0.2rem;
          &:not(details) {
              display: block;
          }
      }

      :focus {
          outline: -webkit-focus-ring-color auto 1px;
      }

      hr {
          border: none;
          border-top: 1px solid black;
      }

      code {
          display: inline-block;
          background-color: #e7edf3;
          background-color: rgb(230, 230, 230);
          border: solid 1px #d6dde4;
          border-radius: 3px;
          line-height: 1;
          padding-block: 0.2rem;
          padding-inline: 0.2rem;
      }

      header {
          display: block;
          font-size: 0.9rem;
          & > h1 {
              font-size: 1.6rem;
              margin-block-start: 0.2rem;
              margin-block-end: 0.2rem;
          }
      }

      div#edit-area {
          & > details {
              &#instruction-area li label {
                  width: 7.2rem;
              }
              &#environment-area li label {
                  width: 5.7rem;
              }
              &#instruction-area input {
                  width: 1.0rem;
              }
              &#environment-area input {
                  width: 5.3rem;
              }

              & > summary {
                  width: fit-content;
                  &:hover {
                      cursor: pointer;
                  }
              }
              & ul.details-content {
                  border: 1px solid black;
                  border-radius: 3px;
                  font-size: 0.9rem;
                  margin: 0px;
                  padding: 4px;
                  width: calc(99% - 4px);

                  display: block;
                  word-break: keep-all;
                  white-space: nowrap;
                  overflow-x: auto;
                  overscroll-behavior-x: auto;
                  &::-webkit-scrollbar {
                      display: none;
                  }
              }
              & li {
                  list-style: none;
                  line-height: 1.7;
                  & label {
                      display: inline-block;
                  }
                  & .label:after {
                      display: inline-block;
                      content: "=";
                      padding-inline: 0.2rem;
                  }
                  & span.comment {
                      display: inline-block;
                      padding-inline-end: 0.2rem;
                  }
              }
              & input {
                  appearance: none;
                  display: inline;
                  line-height: 1.2;
                  vertical-align: middle;
                  color: black;
                  background-color: white;
                  outline: 1px solid black;
                  border: none;
                  border-radius: 3px;
                  margin: 0px -0.2rem;
                  padding: 0px;
                  padding-block: calc(0.2rem - 1px);
                  padding-inline: 0.2rem;
                  &[type="number"]::-webkit-inner-spin-button,
                  &[type="number"]::-webkit-outer-spin-button {
                      appearance: none;
                  }
                  &:invalid {
                      outline: 2px dashed red;
                      outline-offset: -1px;
                  }
                  &:disabled {
                      color: rgb(170, 170, 170);
                      background-color: rgb(240, 240, 240);
                      outline-color: rgb(120, 120, 120);
                      opacity: 0.7;
                  }
                  &:focus {
                      outline: -webkit-focus-ring-color auto 1px;
                  }
              }

              .label:not(& .label) {
                  display: block;
              }
              .label:not(& li .label)::after {
                  content: ":";
              }
          }

          & textarea {
              display: block;
              resize: vertical;
              overflow-y: auto;
              overscroll-behavior-y: auto;
              padding: 4px;
              width: calc(99% - 4px);
              border: 1px solid black;
              border-radius: 3px;
              white-space: pre-wrap;
              word-break: break-all;
              &#source {
                  height: 5.9em;
              }
              &#input {
                  height: 2.9em;
              }
              &:disabled {
                  color: rgb(170, 170, 170);
                  background-color: rgb(240, 240, 240);
                  border-color: rgb(120, 120, 120);
                  opacity: 0.7;
              }
              &:focus {
                  outline: -webkit-focus-ring-color auto 1px;
              }
          }
      }

      div#run-area {
          & ul {
              font-size: 0.9em;
              margin: 0px;
              padding: 0px;
          }
          & li {
              list-style: none;
              line-height: 1.5;
          }
          & button {
              appearance: none;
              display: inline-block;
              width: 5em;
              cursor: pointer;
              text-align: center;
              color: black;
              background-color: rgb(240, 240, 240);
              outline: 1px solid black;
              border: none;
              border-radius: 3px;
              line-height: 1;
              padding-block: calc(0.2rem - 1px);
              padding-inline: 0.2rem;
              &:disabled {
                  color: rgb(170, 170, 170);
                  background-color: rgb(240, 240, 240);
                  outline-color: rgb(120, 120, 120);
                  opacity: 0.7;
              }
              &:focus {
                  outline: -webkit-focus-ring-color auto 1px;
              }
          }
      }

      div#program,
      div#memory,
      div#output {
          display: block;
          resize: vertical;
          overflow-y: auto;
          overscroll-behavior-y: auto;
          padding: 4px;
          width: calc(99% - 4px);
          height: 5.9em;
          border: 1px solid black;
          border-radius: 3px;
          white-space: pre-wrap;
      }
      div#program,
      div#output {
          word-break: break-all;
      }
      :is(div#program, div#memory) > span.highlight {
          background-color: lime;
      }

      aside {
          display: block;
          font-size: 0.9rem;
          & > h2 {
              font-size: 1.4rem;
              margin-block-start: 0.2rem;
              margin-block-end: 0.2rem;
          }
      }

      footer {
          display: block;
          font-size: 0.9rem;
      }

      /* モバイル端末用 */
      @media
      only screen
      and (orientation: portrait)
      and (max-width: 560px) {
          html {
              font-size: 18px;
          }
          textarea#source,
          div#program,
          div#memory,
          div#output {
              height: 3.6rem;
          }
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Brainfuck Interpreter</h1>
    </header>
    <hr>

    <main>
      <div id="edit-area" class="area">
        <details id="instruction-area" class="area">
          <summary class="label" title="命令パラメータを設定します">instruction parameter</summary>
          <ul class="details-content">
            <li>
              <span class="label"><label for="PTR_INCREMENT"><code>PTR_INCREMENT</code></label></span>
              <input type="text" id="PTR_INCREMENT" name="PTR_INCREMENT" required value=">" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタをインクリメントする</span>
            </li>
            <li>
              <span class="label"><label for="PTR_DECREMENT"><code>PTR_DECREMENT</code></label></span>
              <input type="text" id="PTR_DECREMENT" name="PTR_DECREMENT" required value="<" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタをデクリメントする</span>
            </li>
            <li>
              <span class="label"><label for="VAL_INCREMENT"><code>VAL_INCREMENT</code></label></span>
              <input type="text" id="VAL_INCREMENT" name="VAL_INCREMENT" required value="+" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタが指す値をインクリメントする</span>
            </li>
            <li>
              <span class="label"><label for="VAL_DECREMENT"><code>VAL_DECREMENT</code></label></span>
              <input type="text" id="VAL_DECREMENT" name="VAL_DECREMENT" required value="-" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタが指す値をデクリメントする</span>
            </li>
            <li>
              <span class="label"><label for="VAL_INPUT"><code>VAL_INPUT</code></label></span>
              <input type="text" id="VAL_INPUT" name="VAL_INPUT" required value="," minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">入力から1文字読み込んで、ポインタが指す先に代入する</span>
            </li>
            <li>
              <span class="label"><label for="VAL_OUTPUT"><code>VAL_OUTPUT</code></label></span>
              <input type="text" id="VAL_OUTPUT" name="VAL_OUTPUT" required value="." minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタが指す値を文字として出力に書き出す</span>
            </li>
            <li>
              <span class="label"><label for="LOOP_BEGIN"><code>LOOP_BEGIN</code></label></span>
              <input type="text" id="LOOP_BEGIN" name="LOOP_BEGIN" required value="[" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタが指す値が0なら、対応する<code>LOOP_END</code>の直後にジャンプする</span>
            </li>
            <li>
              <span class="label"><label for="LOOP_END"><code>LOOP_END</code></label></span>
              <input type="text" id="LOOP_END" name="LOOP_END" required value="]" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ポインタが指す値が0でないなら、対応する<code>LOOP_BEGIN</code>の直後にジャンプする</span>
            </li>
            <li>
              <span class="label"><label for="BREAK_POINT"><code>BREAK_POINT</code></label></span>
              <input type="text" id="BREAK_POINT" name="BREAK_POINT" required value="@" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">ブレークポイント(実行を一時停止する)</span>
            </li>
            <li>
              <span class="label"><label for="COMMENT_LINE"><code>COMMENT_LINE</code></label></span>
              <input type="text" id="COMMENT_LINE" name="COMMENT_LINE" required value="#" minlength="1" maxlength="1" title="長さ1の文字列を重複なく入力してください">
              <span class="comment">コメント行</span>
            </li>
          </ul>
        </details>
        <details id="environment-area" class="area">
          <summary class="label" title="環境パラメータを設定します">environment parameter</summary>
          <ul class="details-content">
            <li>
              <span class="label"><label for="PTR_MAX"><code>PTR_MAX</code></label></span>
              <input type="number" id="PTR_MAX" name="PTR_MAX" required value="255" min="0" max="65535" step="1" title="0以上65535以下の整数を入力してください">
              <span class="comment">メモリアドレスの上限値(下限値は0)</span>
            </li>
            <li>
              <span class="label"><label for="VAL_MAX"><code>VAL_MAX</code></label></span>
              <input type="number" id="VAL_MAX" name="VAL_MAX" required value="255" min="0" max="4294967295" step="1" title="0以上4294967295以下の整数を入力してください">
              <span class="comment">メモリセルに格納できる上限値(下限値は0)</span>
            </li>
            <li>
              <span class="label"><label for="STEP_MAX"><code>STEP_MAX</code></label></span>
              <input type="number" id="STEP_MAX" name="STEP_MAX" required value="20000" min="0" max="1000000" step="1" title="0以上1000000以下の整数を入力してください">
              <span class="comment">総実行ステップ数の上限値(無限ループ抑止)</span>
            </li>
            <li>
              <span class="label"><label for="DELAY_MSEC"><code>DELAY_MSEC</code></label></span>
              <input type="number" id="DELAY_MSEC" name="DELAY_MSEC" required value="1" min="0" max="5000" step="1" title="0以上5000以下の整数を入力してください">
              <span class="comment">一括実行時の各命令の待機時間[ms](0[ms]は最終結果のみ表示)</span>
            </li>
          </ul>
        </details>
        <hr>

        <div id="source-area" class="area">
          <label class="label" for="source">source code</label>
          <textarea type="text" id="source" name="program" title="ソースコードを入力してください" spellcheck="false">+[>,.]</textarea>
        </div>
        <div id="input-area" class="area">
          <label class="label" for="input">input</label>
          <textarea type="text" id="input" name="input" title="入力命令に対するデータを入力してください" spellcheck="false">Hello World!</textarea>
        </div>
        <div id="run-area" class="area">
          <ul>
            <li>
              <button type="button" id="run" id="run" name="run" title="プログラム終端まで実行されます">RUN</button>
              <span>一括実行</span>
            </li>
            <li>
              <button type="button" id="step-run" name="stepRun" title="プログラムカウンタが指す命令が実行されます">STEPRUN</button>
              <span>ステップ実行</span>
            </li>
            <li>
              <button type="button" id="kill" name="kill" title="プログラム実行を強制終了します">KILL</button>
              <span>強制終了</span>
            </li>
          </ul>
        </div>
      </div>
      <hr>

      <div id="result-area" class="area">
        <div id="program-area" class="area">
          <span class="label">program</span>
          <div id="program" title="プログラムカウンタが指す命令が強調表示されます"></div>
        </div>
        <div id="memory-area" class="area">
          <span class="label">memory</span>
          <div id="memory" title="ポインタが指すメモリが強調表示されます"></div>
        </div>
        <div id="output-area" class="area">
          <span class="label">output</span>
          <div id="output" title="出力命令に対するデータが出力されます"></div>
        </div>
      </div>
    </main>
    <hr>

    <aside>
      <h2>Sample</h2>
      <ul>
        <li>
          <a href="bf_samples.bf" target="_blank">sample Brainfuck code</a>
        </li>
        <li>
          <a href="https://sange.fi/esoteric/brainfuck/" target="_blank">Index of /esoteric/brainfuck</a>
        </li>
      </ul>
      <h2>Reference</h2>
      <ul>
        <li>
          <a href="https://ja.wikipedia.org/wiki/Brainfuck" target="_blank">Brainfuck - Wikipedia</a>
        </li>
        <li>
          <a href="https://www.nicovideo.jp/watch/sm10384056" target="_blank">【プログラミング】Brainf*ckを作ってみた【実況解説・番外編】</a>
        </li>
        <li>
          <a href="http://www.kmonos.net/alang/etc/brainfuck.php" target="_blank">Brainf*ck</a>
        </li>
        <li>
          <a href="https://yukikurage.github.io/brainf__k/" target="_blank">Yuki Brainf**k</a>
        </li>
      </ul>
    </aside>
    <hr>

    <footer>
      <p>&copy;Copyright 2023 by nobody. All rights reversed.</p>
    </footer>

    <script>
      window.addEventListener("DOMContentLoaded", () => {
      "use strict";  // 厳格モード

      // 汎用関数群

      /** 強制終了
       * @description 呼び出し元にcatchがなければプログラムが終了する
       * @param {string} [str="exit"] エラーメッセージ
       */
      function exit(message = "exit") {
          // console.log("exit");  // デバッグ用

          throw new Error(message);
      }

      /** エラー用アラート
       * @description 先行処理が完了してからエラー用アラートを表示する
       * @param {string} [message="alert"] エラーメッセージ
       */
      function errorAlert(message = "alert") {
          // console.group("errorAlert");  // デバッグ用

          setTimeout(() => {
              alert(`Error: ${message}`);
          }, 1);

          // console.groupEnd("errorAlert");  // デバッグ用
      }

      /** エラー用ログ
       * @description エラー用ログを表示する
       * @param {string} [message="log"] エラーメッセージ
       */
      function errorLog(message = "log") {
          // console.group("errorLog");  // デバッグ用

          console.error(`Error: ${message}`);

          // console.groupEnd("errorLog");  // デバッグ用
      }

      /** 経過時間計測クロージャ
       * @description コンソールタイマーの模倣
       * @method begin 開始
       * @method log 記録
       * @method end 終了
       */
      const consoleTime = (() => {
          if (Object.hasOwn(console, "time")
          && Object.hasOwn(console, "timeLog")
          && Object.hasOwn(console, "timeEnd")) {
              return Object.freeze({
                  /** 開始
                   * @description タイマーの作成
                   * @param {string} [label="default"] タイマーのラベル
                   */
                  begin: (label = "default") => {
                      console.time(label);
                  },

                  /** 記録
                   * @description 経過時間をコンソール表示
                   * @param {string} [label="default"] タイマーのラベル
                   */
                  log: (label = "default") => {
                      console.timeLog(label);
                  },

                  /** 終了
                   * @description 経過時間をコンソール表示, タイマーの削除
                   * @param {string} [label="default"] タイマーのラベル
                   */
                  end: (label = "default") => {
                      console.timeEnd(label);
                  },
              });
          } else {
              // 模倣
              const lastDateMap = new Map();
              const MAP_SIZE_MAX = 10000;
              return Object.freeze({
                  /** 開始
                   * @description タイマーの作成
                   * @param {string} [label="default"] タイマーのラベル
                   */
                  begin: (label = "default") => {
                      if (lastDateMap.has(label)) {
                          console.warn(`Timer "${label}" already exists`);
                          return;
                      }
                      if (lastDateMap.size >= MAP_SIZE_MAX) {
                          console.warn("Timer num is full.");
                          return;
                      }

                      lastDateMap.set(label, performance.now());
                  },

                  /** 記録
                   * @description 経過時間をコンソール表示
                   * @param {string} [label="default"] タイマーのラベル
                   */
                  log: (label = "default") => {
                      if (!lastDateMap.has(label)) {
                          console.warn(`Timer "${label}" doesn't exist.`);
                          return;
                      }

                      const lastDate = lastDateMap.get(label);
                      const nowDate = performance.now();
                      const pastTime = nowDate - lastDate;
                      console.log(`${label}: ${pastTime}ms`);
                  },

                  /** 終了
                   * @description 経過時間をコンソール表示, タイマーの削除
                   * @param {string} [label="default"] タイマーのラベル
                   */
                  end: (label = "default") => {
                      if (!lastDateMap.has(label)) {
                          console.warn(`Timer "${label}" doesn't exist.`);
                          return;
                      }

                      const lastDate = lastDateMap.get(label);
                      const nowDate = performance.now();
                      const pastTime = nowDate - lastDate;
                      lastDateMap.delete(label);
                      console.log(`${label}: ${pastTime} ms`);
                  },
              });
          }
      })();

      // DOM API

      // div#edit-area
      const DOM_INSTRUCTIONS = document.querySelectorAll("details#instruction-area input");
      const DOM_ENVIRONMENTS = document.querySelectorAll("details#environment-area input");
      const DOMSource = document.querySelector("textarea#source");
      const DOMInput = document.querySelector("textarea#input");
      const DOMRun = document.querySelector("button#run");
      const DOMStepRun = document.querySelector("button#step-run");
      const DOMKill = document.querySelector("button#kill");
      // div#result-area
      const DOMProgram = document.querySelector("div#program");
      const DOMMemory = document.querySelector("div#memory");
      const DOMOutput = document.querySelector("div#output");

      /** Brainfuck命令パラメータ既定値 */
      const DEFAULT_INSTRUCTIONS = Object.freeze({
          PTR_INCREMENT: ">",  // ポインタをインクリメントする
          PTR_DECREMENT: "<",  // ポインタをデクリメントする
          VAL_INCREMENT: "+",  // ポインタが指す値をインクリメントする
          VAL_DECREMENT: "-",  // ポインタが指す値をデクリメントする
          VAL_INPUT    : ",",  // 入力から1文字読み込んで、ポインタが指す先に代入する
          VAL_OUTPUT   : ".",  // ポインタが指す値を文字として出力に書き出す
          LOOP_BEGIN   : "[",  // ポインタが指す値が0なら、対応する]の直後にジャンプする
          LOOP_END     : "]",  // ポインタが指す値が0でないなら、対応する[の直後にジャンプする
          BREAK_POINT  : "@",  // ブレークポイント(実行を一時停止する)
          COMMENT_LINE : "#",  // コメント行
      });

      /** Brainfuck環境パラメータ既定値 */
      const DEFAULT_ENVIRONMENTS = Object.freeze({
          PTR_MAX   : 255  ,  // メモリアドレスの上限値(下限値は0);
          VAL_MAX   : 255  ,  // メモリセルに格納できる上限値(下限値は0);
          STEP_MAX  : 20000,  // 総実行ステップ数の上限値(無限ループ抑止);
          DELAY_MSEC: 1    ,  // 一括実行時の各命令の待機時間[ms], 0[ms]は最終結果のみ表示
      });

      // Brainfuck用パラメータ設定検証用
      let INSTRUCTIONS = structuredClone(DEFAULT_INSTRUCTIONS);
      let ENVIRONMENTS = structuredClone(DEFAULT_ENVIRONMENTS);

      // Brainfuck用変数
      let program = "";  // プログラム
      let programCounter = 0;  // プログラムカウンタ
      let programCounterPrev = 0;  // 直前のプログラムカウンタ
      let loopStack = [];  // ループネスト用スタック
      let memory = [];  // メモリ
      let pointer = 0;  // ポインタ
      let pointerPrev = 0;  // 直前のポインタ
      let input = "";  // 入力バッファ
      let inputCounter = 0;  // 入力バッファのカウンタ
      let output = "";  // 出力バッファ
      let isInit = false;  // 初期化済みかどうか
      let isStepRun = false;  // ステップ実行かどうか
      let isError = false;  // プログラムにエラーがあるかどうか
      let step = 0;  // 総ステップ数

      // エントリー
      main();

      /** メイン */
      function main() {
          // console.group("main");  // デバッグ用

          const DOMEditArea = document.querySelector("div#edit-area");  // バブリング用
          const DOMInstructionArea = document.querySelector("details#instruction-area");
          const DOMEnvironmentArea = document.querySelector("details#environment-area");

          let isFocusedAny = false;  // フォーカス中かどうか

          // モバイル端末用設定
          setMobileDevice();

          // 既定初期化
          scroll(0, 0);
          defineParameter();
          initialize();

          // Brainfuck用パラメータ設定検証
          DOMEditArea.addEventListener("input", () => {
              // console.group("edit-area input");  // デバッグ用

              initialize();

              // console.group("edit-area input");  // デバッグ用
          });

          // 一括実行
          DOMRun.addEventListener("click", async () => {
              // console.group("run click");  // デバッグ用

              isStepRun = false;
              await run();

              // console.groupEnd("run click");  // デバッグ用
          });

          // ステップ実行
          DOMStepRun.addEventListener("click", async () => {
              // console.group("step-run click");  // デバッグ用

              isStepRun = true;
              await run();

              // console.groupEnd("step-run click");  // デバッグ用
          });

          // 強制終了
          DOMKill.addEventListener("click", async () => {
              // console.group("kill click");  // デバッグ用

              isError = true;
              if (isStepRun) {
                  await run();
                  isStepRun = false;
              }

              // console.groupEnd("kill click");  // デバッグ用
          });

          // フォーカスを当てる
          DOMEditArea.addEventListener("focusin", (event) => {
              // console.group("edit-area focusin");  // デバッグ用

              const isFocusabled = event.target.matches('input:is([type="text"], [type="number"]), textarea');
              // console.log({isFocusabled});  // デバッグ用
              if (!isFocusabled) return;

              isFocusedAny = true;

              // console.groupEnd("edit-area focusin");  // デバッグ用
          });

          // フォーカスを外す
          DOMEditArea.addEventListener("focusout", () => {
              // console.group("edit-area focusout");  // デバッグ用

              isFocusedAny = false;

              // console.groupEnd("edit-area focusout");  // デバッグ用
          });

          // ショートカットキー設定
          window.addEventListener("keyup", (event) => {
              // console.group(`window keyup ${event.key}`);  // デバッグ用

              // console.log({isFocusedAny});  // デバッグ用

              // フォーカス中なら無効
              if (isFocusedAny) return;

              const clickEvent = new Event("click");
              switch (event.key) {
                  case "i": // Brainfuck命令パラメータ設定アコーディオン開閉
                      DOMInstructionArea.open = !DOMInstructionArea.open;
                      break;
                  case "e": // Brainfuck環境パラメータ設定アコーディオン開閉
                      DOMEnvironmentArea.open = !DOMEnvironmentArea.open;
                      break;
                  case "/": // 最上位のウィジェットにフォーカス
                      const DOMFirstWidget = document.querySelector(":is(input, textarea, button, select):not(:disabled)");
                      if (DOMFirstWidget.matches("details#instruction-area *")) {
                          DOMInstructionArea.open = true;
                      }
                      if (DOMFirstWidget.matches("details#environment-area *")) {
                          DOMEnvironmentArea.open = true;
                      }
                      DOMFirstWidget.focus();
                      break;
                  case "r": // 一括実行
                      if (!DOMRun.disabled) {
                          DOMRun.dispatchEvent(clickEvent);
                      }
                      break;
                  case "s": // ステップ実行
                      if (!DOMStepRun.disabled) {
                          DOMStepRun.dispatchEvent(clickEvent);
                      }
                      break;
                  case "k": // 強制終了
                      if (!DOMKill.disabled) {
                          DOMKill.dispatchEvent(clickEvent);
                      }
                      break;
                  default:
                      break;
              }

              // console.groupEnd(`window keyup ${event.key}`);  // デバッグ用
          });

          // ウィンドウ離脱抑止
          window.addEventListener("beforeunload", (event) => {
              // console.group("window beforeunload");  // デバッグ用

              // 実行中でないなら確認を求めない
              if (!(programCounter < program.length)) return;

              event.preventDefault();
              event.returnValue = "";
              return "";

              // console.groupEnd("window beforeunload");  // デバッグ用
          });

          // console.groupEnd("main");  // デバッグ用
      }

      /** モバイル端末用設定 */
      function setMobileDevice() {
          // console.group("setMobileDevice");  // デバッグ用

          const DOMInputNumberList = document.querySelectorAll('input[type="number"]');
          const regExpMobile = /(iPhone|Android).+Mobile/;
          const queryMobile = "(orientation: portrait) and (max-width: 560px)";
          if (regExpMobile.test(navigator.userAgent) || matchMedia(queryMobile).matches) {
              DOMInputNumberList.forEach((DOMInput) => {
                  DOMInput.type = "text";
                  DOMInput.inputMode = "numeric";
                  DOMInput.pattern = "^([1-9][0-9]*|0)$";
              });
          }

          // console.groupEnd("setMobileDevice");  // デバッグ用
      }

      /** 初期化群 */
      function initialize() {
          // console.group("initialize");  // デバッグ用

          if (validateParameter()) {
              init();
              isInit = false;
              createResult();
              drawResult();
          }

          // console.groupEnd("initialize");  // デバッグ用
      }

      /** Brainfuck用パラメータ既定値設定 */
      function defineParameter() {
          // console.group("defineParameter");  // デバッグ用

          // Brainfuck命令パラメータ
          for (const DOM_INSTRUCTION of DOM_INSTRUCTIONS) {
              DOM_INSTRUCTION.value = DEFAULT_INSTRUCTIONS[DOM_INSTRUCTION.id];
          }
          // Brainfuck環境パラメータ
          for (const DOM_ENVIRONMENT of DOM_ENVIRONMENTS) {
              DOM_ENVIRONMENT.value = DEFAULT_ENVIRONMENTS[DOM_ENVIRONMENT.id];
          }

          // console.groupEnd("defineParameter");  // デバッグ用
      }

      /** Brainfuck用パラメータ設定検証 */
      function validateParameter() {
          // console.group("validateParameter");  // デバッグ用

          let isValidAll = true;  // すべて制約を満たすかどうか

          // Brainfuck命令パラメータ
          for (const DOM_INSTRUCTION of DOM_INSTRUCTIONS) {
              const id = DOM_INSTRUCTION.id;
              const value = DOM_INSTRUCTION.value;
              const validity = DOM_INSTRUCTION.validity;

              DOM_INSTRUCTION.setCustomValidity("");
              if (validity.valid) {
                  INSTRUCTIONS[id] = value;
              } else {
                  isValidAll = false;
                  DOM_INSTRUCTION.setCustomValidity("invalid");
                  if (validity.badInput) {
                      DOM_INSTRUCTION.setCustomValidity("invalid: badInput");
                  } else if (validity.valueMissing) {
                      DOM_INSTRUCTION.setCustomValidity("invalid: valueMissing");
                  } else if (validity.tooLong) {
                      DOM_INSTRUCTION.setCustomValidity("invalid: tooLong");
                  } else if (validity.tooShort) {
                      DOM_INSTRUCTION.setCustomValidity("invalid: tooShort");
                  }
              }
          }
          // 重複は不可
          for (const DOM_INSTRUCTION of DOM_INSTRUCTIONS) {
              if (Object.values(INSTRUCTIONS).filter((value) => value === DOM_INSTRUCTION.value).length > 1) {
                  isValidAll = false;
                  DOM_INSTRUCTION.setCustomValidity("invalid: unique");
              }
              DOM_INSTRUCTION.reportValidity();
          }

          // Brainfuck環境パラメータ
          const regExpInt = /^([1-9][0-9]*|0)$/;  // 整数のみ可
          for (const DOM_ENVIRONMENT of DOM_ENVIRONMENTS) {
              const id = DOM_ENVIRONMENT.id;
              const value = Number(DOM_ENVIRONMENT.value);
              const min = Number(DOM_ENVIRONMENT.min);
              const max = Number(DOM_ENVIRONMENT.max);
              const validity = DOM_ENVIRONMENT.validity;

              DOM_ENVIRONMENT.setCustomValidity("");
              if (validity.valid && regExpInt.test(String(value)) && min <= value && value <= max) {
                  ENVIRONMENTS[id] = value;
              } else {
                  isValidAll = false;
                  DOM_ENVIRONMENT.setCustomValidity("invalid");
                  if (validity.badInput) {
                      DOM_ENVIRONMENT.setCustomValidity("invalid: badInput");
                  } else if (validity.valueMissing) {
                      DOM_ENVIRONMENT.setCustomValidity("invalid: valueMissing");
                  } else if (validity.rangeOverflow || value > max) {
                      DOM_ENVIRONMENT.setCustomValidity("invalid: rangeOverflow");
                  } else if (validity.rangeUnderflow || value < min) {
                      DOM_ENVIRONMENT.setCustomValidity("invalid: rangeUnderflow");
                  } else if (validity.stepMismatch) {
                      DOM_ENVIRONMENT.setCustomValidity("invalid: stepMismatch");
                  }
              }
              DOM_ENVIRONMENT.reportValidity();
          }
          if (isValidAll) {
              ENVIRONMENTS.PTR_MAX++;
              ENVIRONMENTS.VAL_MAX++;
          }

          // Brainfuck用パラメータのいずれかが制約を満たさないなら無効化
          DOMRun.disabled = !isValidAll;
          DOMStepRun.disabled = !isValidAll;

          // console.groupEnd("validateParameter");  // デバッグ用

          return isValidAll;
      }

      /** Brainfuck用変数初期化 */
      function init() {
          // console.group("init");  // デバッグ用

          program = DOMSource.value;
          programCounter = 0;
          programCounterPrev = 0;
          loopStack = [];
          memory = new Array(ENVIRONMENTS.PTR_MAX).fill(0);
          pointer = 0;
          pointerPrev = 0;
          input = DOMInput.value;
          inputCounter = 0;
          output = "";
          isInit = true;
          // isStepRun = false;
          isError = false;
          step = 0;

          // console.groupEnd("init");  // デバッグ用
      }

      /** 描画初期化 */
      function createResult() {
          // console.group("createResult");  // デバッグ用

          // プログラム
          while (DOMProgram.firstChild) {
              DOMProgram.removeChild(DOMProgram.firstChild);
          }
          for (let i = 0; i < program.length; i++) {
              const DOMSpan = document.createElement("span");
              DOMSpan.dataset.index = String(i);
              DOMSpan.className = "";
              DOMSpan.textContent = (program[i] === "\n") ?" \n" :program[i];
              DOMProgram.appendChild(DOMSpan);
          }

          // メモリ
          while (DOMMemory.firstChild) {
              DOMMemory.removeChild(DOMMemory.firstChild);
          }
          const digit = String(ENVIRONMENTS.VAL_MAX-1).replace("-", "").length;
          for (let i = 0; i < ENVIRONMENTS.PTR_MAX; i++) {
              const DOMSpan = document.createElement("span");
              DOMSpan.dataset.index = String(i);
              DOMSpan.className = "";
              DOMSpan.textContent = String(memory[i]).padStart(digit, "0");
              DOMMemory.appendChild(DOMSpan);
              const DOMTextSP = document.createTextNode(" ");
              DOMMemory.appendChild(DOMTextSP);
          }

          // 出力
          DOMOutput.textContent = "";

          // console.groupEnd("createResult");  // デバッグ用
      }

      /** 描画 */
      function drawResult() {
          // console.group("drawResult");  // デバッグ用

          if (!isInit || isStepRun || ENVIRONMENTS.DELAY_MSEC > 0) {
              // ステップ実行または待機有りなら途中結果を描画

              // プログラム
              if (programCounterPrev < program.length) {
                  const DOMProgramCounterPrev = DOMProgram.querySelector(`span[data-index="${programCounterPrev}"]`);
                  DOMProgramCounterPrev.classList.remove("highlight");
              }
              if (programCounter < program.length) {
                  const DOMProgramCounter = DOMProgram.querySelector(`span[data-index="${programCounter}"]`);
                  DOMProgramCounter.classList.add("highlight");
              }
              programCounterPrev = programCounter;

              // メモリ
              const DOMPointerPrev = DOMMemory.querySelector(`span[data-index="${pointerPrev}"]`);
              DOMPointerPrev.classList.remove("highlight");
              const DOMPointer = DOMMemory.querySelector(`span[data-index="${pointer}"]`);
              DOMPointer.classList.add("highlight");
              const digit = String(ENVIRONMENTS.VAL_MAX-1).replace("-", "").length;
              DOMPointer.textContent = String(memory[pointer]).padStart(digit, "0");
              pointerPrev = pointer;
          } else {
              // 最終結果のみ描画

              // プログラム
              const DOMProgramCounterAll = DOMProgram.querySelectorAll(`span[data-index]`);
              for (const DOMProgramCounter of DOMProgramCounterAll) {
                  DOMProgramCounter.classList.remove("highlight");
              }

              // メモリ
              const digit = String(ENVIRONMENTS.VAL_MAX-1).replace("-", "").length;
              for (let i = 0; i < ENVIRONMENTS.PTR_MAX; i++) {
                  const DOMPointer = DOMMemory.querySelector(`span[data-index="${i}"]`);
                  DOMPointer.classList.remove("highlight");
                  if (i === pointer) {
                      DOMPointer.classList.add("highlight");
                  }
                  DOMPointer.textContent = String(memory[i]).padStart(digit, "0");
              }
          }

          // 出力
          DOMOutput.textContent = output;

          // console.groupEnd("drawResult");  // デバッグ用
      }

      /** 実行 */
      async function run() {
          // console.group("run");  // デバッグ用

          // 初回
          if (!isInit) {
              init();
              createResult();
              drawResult();
              console.log("This code was begun.");  // ログ用
              consoleTime.begin("run time");  // ログ用
          }
          // 無効化
          for (const DOM_INSTRUCTION of DOM_INSTRUCTIONS) {
              DOM_INSTRUCTION.disabled = true;
          }
          for (const DOM_ENVIRONMENT of DOM_ENVIRONMENTS) {
              DOM_ENVIRONMENT.disabled = true;
          }
          DOMSource.disabled = true;
          DOMInput.disabled = true;
          if (!isStepRun) {
              DOMRun.disabled = true;
              DOMStepRun.disabled = true;
          }

          // 実行
          while (!isError && programCounter < program.length) {
              // console.log({programCounter});  // デバッグ用
              // console.log({step});  // デバッグ用

              // 無限ループならエラー
              if (step >= ENVIRONMENTS.STEP_MAX) {
                  errorAlert(`Cannot run more than ${ENVIRONMENTS.STEP_MAX} steps.`);  // アラート用
                  errorLog(`Cannot run more than ${ENVIRONMENTS.STEP_MAX} steps.`);  // ログ用
                  isError = true;
                  break;
              }

              // コード解析
              interpret();
              programCounter++;

              // エラーがあれば終了
              if (isError) break;

              // ステップ実行または待機有りなら描画
              if (isStepRun || ENVIRONMENTS.DELAY_MSEC > 0) {
                  drawResult();
              }

              // console.time("sleep");  // デバッグ用
              await sleep(ENVIRONMENTS.DELAY_MSEC);  // 一時停止
              // console.timeEnd("sleep");  // デバッグ用

              // ステップ実行はループしない
              // consoleTime.log("run time");  // ログ用
              // console.groupEnd("run");  // デバッグ用
              if (isStepRun && programCounter < program.length) return;
          }

          // 終了
          drawResult();
          isInit = false;
          // 有効化
          for (const DOM_INSTRUCTION of DOM_INSTRUCTIONS) {
              DOM_INSTRUCTION.disabled = false;
          }
          for (const DOM_ENVIRONMENT of DOM_ENVIRONMENTS) {
              DOM_ENVIRONMENT.disabled = false;
          }
          DOMSource.disabled = false;
          DOMInput.disabled = false;
          DOMRun.disabled = false;
          DOMStepRun.disabled = false;

          // ログ出力
          console.log(`run step: ${step}`);  // ログ用
          consoleTime.end("run time");  // ログ用
          console.log(`This code was ${(isError) ?"terminated" :"finished"}.`);  // ログ用

          // console.groupEnd("run");  // デバッグ用
      }

      /** コード解析 */
      function interpret() {
          // console.group("interpret");  // デバッグ用

          step++;

          switch (program[programCounter]) {
              case INSTRUCTIONS.PTR_INCREMENT:  // ポインタをインクリメントする
                  pointer++;
                  pointer += ENVIRONMENTS.PTR_MAX;
                  pointer %= ENVIRONMENTS.PTR_MAX;
                  break;
              case INSTRUCTIONS.PTR_DECREMENT:  // ポインタをデクリメントする
                  pointer--;
                  pointer += ENVIRONMENTS.PTR_MAX;
                  pointer %= ENVIRONMENTS.PTR_MAX;
                  break;
              case INSTRUCTIONS.VAL_INCREMENT:  // ポインタが指す値をインクリメントする
                  memory[pointer]++;
                  memory[pointer] += ENVIRONMENTS.VAL_MAX;
                  memory[pointer] %= ENVIRONMENTS.VAL_MAX;
                  break;
              case INSTRUCTIONS.VAL_DECREMENT:  // ポインタが指す値をデクリメントする
                  memory[pointer]--;
                  memory[pointer] += ENVIRONMENTS.VAL_MAX;
                  memory[pointer] %= ENVIRONMENTS.VAL_MAX;
                  break;
              case INSTRUCTIONS.VAL_INPUT:  // 入力から1文字読み込んで、ポインタが指す先に代入する
                  if (inputCounter >= input.length) {
                      memory[pointer] = 0;  // 入力命令に対して不足分はNULL文字
                  } else {
                      memory[pointer] = input.charCodeAt(inputCounter)%ENVIRONMENTS.VAL_MAX;  // 文字として入力
                      inputCounter++;
                  }
                  break;
              case INSTRUCTIONS.VAL_OUTPUT:  // ポインタが指す値を文字として出力に書き出す
                  output += String.fromCharCode(memory[pointer]);  // 文字として出力
                  break;
              case INSTRUCTIONS.LOOP_BEGIN:  // ポインタが指す値が0なら、対応する]の直後にジャンプする
                  loopStack.push(programCounter);  // [のプログラムカウンタを保存
                  // 対応する]にジャンプ
                  if (memory[pointer] === 0) {
                      let depth = 0  // ネストの深さ
                      while (programCounter < program.length) {  // コード終端まで探索
                          // [を見つけたらネストを深くする
                          if (program[programCounter] === INSTRUCTIONS.LOOP_BEGIN) {
                              depth++;
                          }
                          // ]を見つけたらネストを浅くする
                          if (program[programCounter] === INSTRUCTIONS.LOOP_END) {
                              depth--;
                          }
                          // 対応する]が見つかったので抜ける
                          if (depth === 0) break;
                          programCounter++;  // プログラムカウンタを進める
                      }

                      // 対応する]が見つかってないならエラー
                      // console.log({depth});  // デバッグ用
                      if (depth > 0) {
                          errorAlert(`Cannot find "${INSTRUCTIONS.LOOP_END}".`);  // アラート用
                          errorLog(`Cannot find "${INSTRUCTIONS.LOOP_END}".`);  // ログ用
                          isError = true;
                          return;
                      }
                      loopStack.pop();  // ループ終わり
                  }
                  break;
              case INSTRUCTIONS.LOOP_END:  // ポインタが指す値が0でないなら、対応する[の直後にジャンプする
                  // [と]の対をチェック
                  // console.log({loopStack});  // デバッグ用
                  if (loopStack.length === 0) {  // スタックが空なら対応する[がない
                      errorAlert(`Cannot find "${INSTRUCTIONS.LOOP_BEGIN}".`);  // アラート用
                      errorLog(`Cannot find "${INSTRUCTIONS.LOOP_BEGIN}".`);  // ログ用
                      isError = true;
                      return;
                  }
                  programCounter = loopStack.pop()-1;  // [にジャンプ
                  break;
              case INSTRUCTIONS.BREAK_POINT:  // ブレークポイント(実行を一時停止する)
                  drawResult();  // 強制描画
                  isStepRun = true  // ステップ実行に移行
                  DOMRun.disabled = false;
                  DOMStepRun.disabled = false;
                  break;
              case INSTRUCTIONS.COMMENT_LINE:   // コメント行
                  // 行末にジャンプ
                  while (program[programCounter] !== "\n") {
                      programCounter++;
                      if (!(programCounter < program.length)) break;
                  }
                  break;
              default:  // 他は無視
                  step--;
                  break;
          }

          // console.groupEnd("interpret");  // デバッグ用
      }

      /** 指定ミリ秒停止
      * @param {number} delayMsec 停止時間[ms]
      */
      function sleep(delayMsec) {
          // console.group("sleep");  // デバッグ用

          return new Promise((resolve) => {
              // 一括実行かつ待機有りなら停止する
              if (!isStepRun && delayMsec > 0) {
                  // delayMsecミリ秒後に履行
                  setTimeout(() => {
                      resolve();
                      // console.groupEnd("sleep");  // デバッグ用
                  }, delayMsec);
              } else {
                  // 即時に履行
                  resolve();
                  // console.groupEnd("sleep");  // デバッグ用
              }
          });
      }
      });
    </script>
  </body>
</html>
