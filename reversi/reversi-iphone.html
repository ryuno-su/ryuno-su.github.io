<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Reversi">
    <title>Reversi</title>
    <style>
      html {
          font-family: "Consolas", "MS Gothic", monospace;
          font-size: 25px;
          box-sizing: border-box;
          overscroll-behavior: none;
          text-size-adjust: 100%;
          -webkit-text-size-adjust: 100%;
      }
      *, *::before, *::after {
          font-family: inherit;
          font-size: 100%;
          box-sizing: inherit;
      }
      body {
          background-color: rgb(200, 200, 200);
      }

      .hidden {
          display: none;
      }

      .area {
          margin: 0.2rem;
          &:not(details) {
              display: block;
          }
      }

      :focus {
          outline: -webkit-focus-ring-color auto 1px;
      }

      hr {
          border: none;
          border-top: 1px solid black;
      }

      header {
          font-size: 0.8rem;
          &.shown {
              display: block;
          }
          &.hidden {
              display: none;
          }
          & > h1 {
              font-size: 1.4rem;
              margin-block-start: 0.2rem;
              margin-block-end: 0.2rem;
          }
      }

      div#template-area {
          &.shown {
              display: block;
          }
          &.hidden {
              display: none;
          }
      }

      svg {
          font-size: 80px;
          width: 80px;
          height: 80px;
          & > rect.background {
              width: 100%;
              height: 100%;
              fill: limegreen;
              stroke: black;
              stroke-width: 1.5px;
          }
          &.not-init_area {
              & > rect.background {
                  fill: white;
              }
          }
          &.lucky {
              & > rect.background {
                  fill: orange;
              }
          }
          &:hover {
              cursor: pointer;
              & > rect.background {
                  fill: lime;
              }
          }
          & > text {
              font-size: 0.5em;
              line-height: 0;
              text-align: center;
              vertical-align: middle;
              fill: green;
              &.shown {
                  display: inline-block;
              }
              &.hidden {
                  display: none;
              }
          }

          &.cell {
              &[data-color="none"] > circle.stone {
                  fill: none;
              }
              &[data-color="black"] > circle.stone {
                  fill: black;
              }
              &[data-color="white"] > circle.stone {
                  fill: white;
              }
              &[data-color="red"] > circle.stone {
                  fill: red;
              }
              &[data-color="blue"] > circle.stone {
                  fill: blue;
              }
              &[data-color="cyan"] > circle.stone {
                  fill: cyan;
              }
              &[data-color="magenta"] > circle.stone {
                  fill: magenta;
              }
              &[data-color="yellow"] > circle.stone {
                  fill: yellow;
              }
              &[data-color="sentinel"] > circle.stone {
                  fill: limegreen;
              }
          }

          &.highlight {
              & > rect.highlight-stone {
                  width: 90%;
                  height: 90%;
                  fill: none;
                  stroke-width: 2.5px;
                  stroke-dasharray: 5.0px, 5.0px;
                  &.highlight-put {
                      stroke-dasharray: none;
                  }
              }
              &[data-color="none"] {
                  & > rect.highlight-stone {
                      stroke: none;
                  }
                  & > circle.stone {
                      fill: none;
                  }
              }
              &[data-color="black"] {
                  & > rect.highlight-stone {
                      stroke: black;
                  }
                  & > circle.stone {
                      fill: black;
                  }
              }
              &[data-color="white"] {
                  & > rect.highlight-stone {
                      stroke: white;
                  }
                  & > circle.stone {
                      fill: white;
                  }
              }
              &[data-color="red"] {
                  & > rect.highlight-stone {
                      stroke: red;
                  }
                  & > circle.stone {
                      fill: red;
                  }
              }
              &[data-color="blue"] {
                  & > rect.highlight-stone {
                      stroke: blue;
                  }
                  & > circle.stone {
                      fill: blue;
                  }
              }
              &[data-color="cyan"] {
                  & > rect.highlight-stone {
                      stroke: cyan;
                  }
                  & > circle.stone {
                      fill: cyan;
                  }
              }
              &[data-color="magenta"] {
                  & > rect.highlight-stone {
                      stroke: magenta;
                  }
                  & > circle.stone {
                      fill: magenta;
                  }
              }
              &[data-color="yellow"] {
                  & > rect.highlight-stone {
                      stroke: yellow;
                  }
                  & > circle.stone {
                      fill: yellow;
                  }
              }
          }

          &.assist {
              & > circle.assist-stone {
                  fill: none;
                  stroke-width: 2.5px;
                  stroke-dasharray: 5.0px, 5.0px;
              }
              &[data-color="none"] > circle.assist-stone {
                  stroke: none;
              }
              &[data-color="black"] > circle.assist-stone {
                  stroke: black;
              }
              &[data-color="white"] > circle.assist-stone {
                  stroke: white;
              }
              &[data-color="red"] > circle.assist-stone {
                  stroke: red;
              }
              &[data-color="blue"] > circle.assist-stone {
                  stroke: blue;
              }
              &[data-color="cyan"] > circle.assist-stone {
                  stroke: cyan;
              }
              &[data-color="magenta"] > circle.assist-stone {
                  stroke: magenta;
              }
              &[data-color="yellow"] > circle.assist-stone {
                  stroke: yellow;
              }
          }
      }

      .color-text {
          font-weight: bold;
          &[data-color="black"] {
              color: black;
          }
          &[data-color="white"] {
              color: white;
              :is(ul#AI_LIST &) {
                  text-shadow: 1px 1px 2px gray;
              }
          }
          &[data-color="red"] {
              color: red;
          }
          &[data-color="blue"] {
              color: blue;
          }
          &[data-color="cyan"] {
              color: cyan;
          }
          &[data-color="magenta"] {
              color: magenta;
          }
          &[data-color="yellow"] {
              color: yellow;
              :is(ul#AI_LIST &) {
                  text-shadow: 1px 1px 2px gray;
              }
          }
          &::before, &::after {
              font-weight: normal;
              color: black;
              text-shadow: none;
          }
      }

      details#parameter-area {
          & > summary {
              width: fit-content;
              &:hover {
                  cursor: pointer;
              }
              &::after {
                  content: ":";
              }
          }
          & > ul.details-content {
              border: 1px solid black;
              border-radius: 3px;
              font-size: 0.9rem;
              margin: 0px;
              padding: 4px;
              width: 99%;

              display: block;
              word-break: keep-all;
              white-space: nowrap;
              overflow-x: auto;
              overscroll-behavior-x: auto;
              &::-webkit-scrollbar {
                  display: none;
              }
              & ul#AI_LIST {
                  display: inline-block;
                  font-size: 1em;
                  margin: 0px;
                  margin-inline-end: 0.2rem;
                  width: fit-content;
                  & li {
                      vertical-align: middle;
                      margin-block-start: -0.2rem;
                      width: fit-content;
                      &.shown {
                          display: inline-block;
                      }
                      &.hidden {
                          display: none;
                      }
                  }
                  & label.label {
                      display: inline;
                  }
              }
          }
          & li {
              list-style: none;
              line-height: 1.5;
              vertical-align: middle;
              width: fit-content;
              &.shown {
                  display: list-item;
              }
              &.hidden {
                  display: none;
              }
              & label, & span[name="label"] {
                  display: inline-block;
                  vertical-align: middle;
                  width: 5.8rem;
              }
              & .label:after {
                  display: inline-block;
                  content: "=";
                  padding-inline: 0.2rem;
              }
          }
          & input {
              &[type="number"], &[type="text"] {
                  appearance: none;
                  width: 1.1rem;
              }
              :is(&[type="number"], &[type="text"]):invalid {
                  outline: 2px dashed red;
                  outline-offset: -1px;
              }
              &[type="number"]::-webkit-inner-spin-button,
              &[type="number"]::-webkit-outer-spin-button {
                  appearance: none;
              }
              &[type="checkbox"] {
                  display: inline-block;
                  margin: 0px;
                  vertical-align: middle;
                  width: 1.1em;
                  height: 1.1em;
              }
          }
          & ul#AI_LIST,
          & input:is([type="number"], [type="text"]),
          & select {
              display: inline-block;
              line-height: 1.1rem;
              height: 1.1rem;
              vertical-align: middle;
              border: none;
              border-radius: 3px;
              margin-inline-start: 0em;

              color: black;
              background-color: white;
              outline: 1px solid black;
              opacity: 1;
          }
          & ul#AI_LIST.disabled,
          & ul#AI_LIST.disabled label.label,
          & input:disabled,
          & select:disabled {
              color: rgb(170, 170, 170);
              background-color: rgba(239, 239, 239, 0.3);
              outline-color: rgb(118, 118, 118);
              opacity: 0.7;
              text-shadow: none;
          }
          & :is(input, select, button):focus {
              outline: -webkit-focus-ring-color auto 1px;
          }
          & ul#AI_LIST,
          & input:is([type="number"], [type="text"]) {
              padding: 0.1rem 0.1rem;
          }
          & select {
              padding: 0.1rem 0.0rem;
              outline: none;
              border: 1px solid black;
              &:disabled {
                  border-color: rgb(118, 118, 118);
              }
          }
          & > button {
              margin-block-start: 0.5em;
          }
      }

      button {
          appearance: none;
          display: inline-block;
          margin: 0px;
          cursor: pointer;
          text-align: center;
          color: black;
          background-color: rgb(239, 239, 239);
          outline: 1px solid black;
          border: none;
          border-radius: 3px;
          line-height: 1;
          padding: 0.1rem 0.2rem;
          &:disabled {
              color: rgb(170, 170, 170);
              background-color: rgba(239, 239, 239, 0.3);
              outline-color: rgb(118, 118, 118);
              opacity: 0.7;
          }
      }

      div#board-area {
          max-width: calc(100vw - 0.2rem);
          max-height: calc(100vw - 0.2rem);
          overflow: auto;
          overscroll-behavior: auto;
          white-space: nowrap;
          & > div#board {
              display: inline-block;
              line-height: 0;
              border: 1.5px solid black;
          }
      }

      div#info-area > div {
          &.shown {
              display: block;
          }
          &.hidden {
              display: none;
          }

          &#turn,
          &#message,
          &#result,
          &#record {
              white-space: pre-wrap;
          }
          &#record {
              word-break: break-all;
          }

          &#turn::before {
              content: "turn: ";
          }
          &#message::before {
              content: "message: ";
          }
          &#result::before {
              content: "result: ";
          }
          &#record::before {
              content: "record: ";
          }
      }

      aside {
          font-size: 0.8rem;
          &.shown {
              display: block;
          }
          &.hidden {
              display: none;
          }
          & > h2 {
              font-size: 1.2rem;
              margin-block-start: 0.2rem;
              margin-block-end: 0.2rem;
          }
      }

      footer {
          font-size: 0.8rem;
          &.shown {
              display: block;
          }
          &.hidden {
              display: none;
          }
      }

      /* モバイル端末用 */
      @media only screen
      and (orientation: portrait)
      and (max-width: 560px) {
          html {
              font-size: 18px;
          }
          svg {
              font-size: 40px;
              width: 40px;
              height: 40px;
              & > rect.background {
                  stroke-width: 0.75px;
              }
              &.highlight > rect.highlight-stone {
                  stroke-width: 1.25px;
                  stroke-dasharray: 2.5px, 2.5px;
              }
              &.assist > circle.assist-stone {
                  stroke-width: 1.25px;
                  stroke-dasharray: 2.5px, 2.5px;
              }
          }
      }
    </style>
  </head>

  <body>
    <header class="shown">
      <h1>Reversi</h1>
      <hr>
    </header>

    <main>
      <div id="template-area" class="area hidden">
        <svg class="cell" data-color="none" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="black" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="white" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="red" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="blue" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="cyan" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="magenta" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="yellow" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="cell" data-color="sentinel" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <hr>

        <svg class="highlight" data-color="none" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="black" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="white" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="red" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="blue" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="cyan" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="magenta" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="highlight" data-color="yellow" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <rect class="highlight-stone" x="5%" y="5%"></rect>
          <circle class="stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <hr>

        <svg class="assist" data-color="none" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="black" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="white" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="red" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="blue" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="cyan" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="magenta" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <svg class="assist" data-color="yellow" version="1.1" xmlns="http://www.w3.org/2000/svg">
          <rect class="background" x="0%" y="0%"></rect>
          <circle class="assist-stone" cx="50%" cy="50%" r="40%"></circle>
          <text class="hidden" x="35%" y="65%"></text>
        </svg>
        <hr>

        <span class="color-text" data-color="black">BLACK</span>
        <span class="color-text" data-color="white">WHITE</span>
        <span class="color-text" data-color="red">RED</span>
        <span class="color-text" data-color="blue">BLUE</span>
        <span class="color-text" data-color="cyan">CYAN</span>
        <span class="color-text" data-color="magenta">MAGENTA</span>
        <span class="color-text" data-color="yellow">YELLOW</span>
      </div>

      <details id="parameter-area" class="area">
        <summary class="label" title="パラメータを設定します">parameter</summary>
        <ul class="details-content">
          <li class="shown">
            <span class="label"><label for="COLOR_NUM">対戦人数</label></span>
            <select id="COLOR_NUM" name="COLOR_NUM" required title="以下のいずれかの整数を選択してください">
              <option value="2" selected>2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
            </select>
          </li>
          <li class="shown">
            <span class="label"><label for="BOARD_WIDTH">盤面横幅</label></span>
            <input type="number" id="BOARD_WIDTH" name="BOARD_WIDTH" required value="8" min="4" max="20" step="1" title="4以上20以下の整数を入力してください">
          </li>
          <li class="shown">
            <span class="label"><label for="BOARD_HEIGHT">盤面縦幅</label></span>
            <input type="number" id="BOARD_HEIGHT" name="BOARD_HEIGHT" required value="8" min="4" max="20" step="1" title="4以上20以下の整数を入力してください">
          </li>
          <li class="shown">
            <span class="label"><span name="label">AI手番</span></span>
            <ul id="AI_LIST">
              <li class="shown">
                <label class="label color-text" for="ai-black" data-color="black">BLACK</label>
                <input type="checkbox" id="ai-black" name="ai-color" value="black" title="AIの色を選択してください">
              </li>
              <li class="shown">
                <label class="label color-text" for="ai-white" data-color="white">WHITE</label>
                <input type="checkbox" id="ai-white" name="ai-color" value="white" title="AIの色を選択してください">
              </li>
              <li class="hidden">
                <label class="label color-text" for="ai-red" data-color="red">RED</label>
                <input type="checkbox" id="ai-red" name="ai-color" value="red" title="AIの色を選択してください">
              </li>
              <li class="hidden">
                <label class="label color-text" for="ai-blue" data-color="blue">BLUE</label>
                <input type="checkbox" id="ai-blue" name="ai-color" value="blue" title="AIの色を選択してください">
              </li>
              <li class="hidden">
                <label class="label color-text" for="ai-cyan" data-color="cyan">CYAN</label>
                <input type="checkbox" id="ai-cyan" name="ai-color" value="cyan" title="AIの色を選択してください">
              </li>
              <li class="hidden">
                <label class="label color-text" for="ai-magenta" data-color="magenta">MAGENTA</label>
                <input type="checkbox" id="ai-magenta" name="ai-color" value="magenta" title="AIの色を選択してください">
              </li>
              <li class="hidden">
                <label class="label color-text" for="ai-yellow" data-color="yellow">YELLOW</label>
                <input type="checkbox" id="ai-yellow" name="ai-color" value="yellow" title="AIの色を選択してください">
              </li>
            </ul>
          </li>
          <li class="hidden">
            <span class="label"><label for="AI_LEVEL">AIレベル</label></span>
            <select id="AI_LEVEL" name="AI_LEVEL" required title="以下のいずれかの整数を選択してください">
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3" selected>3</option>
              <option value="4">4</option>
              <option value="5">5</option>
            </select>
          </li>
          <li class="shown">
            <span class="label"><label for="DELAY_MSEC">待機時間</label></span>
            <select id="DELAY_MSEC" name="DELAY_MSEC" required title="以下のいずれかの値を選択してください">
              <option value="0">0ms</option>
              <option value="1">1ms</option>
              <option value="200">200ms</option>
              <option value="500" selected>500ms</option>
              <option value="2000">2000ms</option>
              <option value="5000">5000ms</option>
            </select>
          </li>
          <li class="shown">
            <span class="label"><label for="LUCKY_MODE">ラッキーマス</label></span>
            <input type="checkbox" id="LUCKY_MODE" name="LUCKY_MODE" value="false" title="ラッキーマスの有無を選択してください">
          </li>
          <li class="shown">
            <span class="label"><label for="HAND_MODE">初期配置手動</label></span>
            <input type="checkbox" id="HAND_MODE" name="HAND_MODE" value="false" title="初期配置を手動で行うかどうか選択してください">
          </li>
        </ul>
        <button type="button" id="enter" name="enter" title="パラメータの変更を確定します">ENTER</button>
        <button type="button" id="reset" name="reset" title="パラメータを既定値に戻します">RESET</button>
      </details>
      <hr>

      <div id="board-area" class="area">
        <div id="board"></div>
      </div>
      <div id="button-area" class="area">
        <button type="button" id="assist" name="assist" title="着手可能なマスが強調表示されます">ASSIST</button>
        <button type="button" id="hint" name="hint" title="各マスの評価値が表示されます">HINT</button>
      </div>
      <hr>

      <div id="info-area" class="area">
        <div id="turn" class="shown color-text" data-color="black">BLACK</div>
        <div id="message" class="shown"></div>
        <div id="wait" class="hidden">
          <label for="progress"></label>
          <progress id="progress" max="100" value="0">0%</progress>
          <output for="progress">0%</output>
        </div>
        <div id="result" class="shown"></div>
        <div id="record" class="hidden"></div>
      </div>
    </main>

    <aside class="shown">
      <hr>
      <h2>Reference</h2>
      <ul>
        <li>
          <a href="https://www.othello.org/lesson/lesson/rule.html" target="_blank">オセロのルール</a>
        </li>
        <li>
          <a href="https://www.nicovideo.jp/watch/sm8391299" target="_blank">【プログラミング】オセロを1時間で作ってみた【実況解説】</a>
        </li>
        <li>
          <a href="https://magazine.techacademy.jp/magazine/22767" target="_blank">JavaScriptでオセロゲームを作成する方法を現役エンジニアが解説【初心者向け】</a>
        </li>
        <li>
          <a href="https://www.othello.org/lesson/lesson/term.html" target="_blank">オセロ用語の基礎知識</a>
        </li>
        <li>
          <a href="https://do2.rojo.jp/shogi/javascript/mania.html?f=1" target="_blank">オセロ棋譜再生[オセ まにあ]</a>
        </li>
      </ul>
    </aside>

    <footer class="shown">
      <hr>
      <p>&copy;Copyright 2023 by nobody. All rights reversed.</p>
    </footer>

    <script>
        window.addEventListener("DOMContentLoaded", () => {
        "use strict";  // 厳格モード

        // 汎用関数群

        /** 強制終了
         * @description 呼び出し元にcatchがなければプログラムが終了する
         * @param {string} [str="exit"] エラーメッセージ
         */
        function exit(str = "exit") {
            // console.log("exit");  // デバッグ用

            throw new Error(str);
        }

        /** 列挙定数群生成
         * @description C言語のenum(列挙定数)相当のObjectを作成
         * @param {...string} keyArray キーの並び
         * @returns 列挙定数群
         */
        function createEnum(...keyArray) {
            // console.group("createEnum");  // デバッグ用

            // console.groupEnd("createEnum");  // デバッグ用
            return Object.fromEntries(Object.entries(keyArray).map(([key, val]) => [String(val), Number(key)]));
        }

        /** min以上max以下の疑似整数乱数
         * @param {number} min 下限値
         * @param {number} max 上限値
         * @returns {number} 疑似整数乱数
         */
        function randomIntRange(min, max) {
            // console.group("randomIntRange");  // デバッグ用

            if (min > max) [min, max] = [max, min];
            min = Math.ceil(min);
            max = Math.floor(max) + 1;

            // console.groupEnd("randomIntRange");  // デバッグ用
            return Math.trunc(Math.random()*(max-min)) + min;
        }

        /** 0以上num未満の疑似整数乱数
         * @param {number} num 疑似整数乱数の候補の個数
         * @returns {number} 疑似整数乱数
         */
        function randomInt(num) {
            // console.group("randomInt");  // デバッグ用

            // console.groupEnd("randomInt");  // デバッグ用
            return randomIntRange(0, num-1);
        }

        // DOM API

        // div#template-area
        const DOMTemplateCells = document.querySelectorAll("div#template-area > svg.cell");
        const DOMTemplateHighlights = document.querySelectorAll("div#template-area > svg.highlight");
        const DOMTemplateAssists = document.querySelectorAll("div#template-area > svg.assist");
        // details#parameter-area
        const DOM_PARAMETERS = Object.freeze({
            COLOR_NUM   : document.querySelector("select#COLOR_NUM"),
            BOARD_WIDTH : document.querySelector("input#BOARD_WIDTH"),
            BOARD_HEIGHT: document.querySelector("input#BOARD_HEIGHT"),
            AI_LIST     : document.querySelectorAll("ul#AI_LIST input"),
            AI_LEVEL    : document.querySelector("select#AI_LEVEL"),
            DELAY_MSEC  : document.querySelector("select#DELAY_MSEC"),
            LUCKY_MODE  : document.querySelector("input#LUCKY_MODE"),
            HAND_MODE   : document.querySelector("input#HAND_MODE"),
        });
        const DOMEnter = document.querySelector("button#enter");
        const DOMReset = document.querySelector("button#reset");
        // main
        const DOMBoard = document.querySelector("div#board");
        let DOMBoardCells = [];  // 描画用盤面

        // div#button-area
        const DOMAssist = document.querySelector("button#assist");
        const DOMHint = document.querySelector("button#hint");
        // div#info-area
        const DOMTurn = document.querySelector("div#turn");
        const DOMMessage = document.querySelector("div#message");
        const DOMWait = document.querySelector("div#wait");
        const DOMResult = document.querySelector("div#result");
        const DOMRecord = document.querySelector("div#record");

        /** パラメータ既定値 */
        const DEFAULT_PARAMETERS = Object.freeze({
            COLOR_NUM   : 2    ,  // 対戦人数
            BOARD_WIDTH : 8    ,  // 盤面横幅
            BOARD_HEIGHT: 8    ,  // 盤面縦幅
            AI_LIST     : []   ,  // AI手番
            AI_LEVEL    : 3    ,  // AIレベル
            DELAY_MSEC  : 500  ,  // 待機時間[ms]
            LUCKY_MODE  : false,  // ラッキー(枚数重み付け)マス有りモードかどうか
            HAND_MODE   : false,  // 初期配置を手動で行うかどうか
        });

        // パラメータ設定検証用
        let PARAMETERS = structuredClone(DEFAULT_PARAMETERS);

        // 手番
        const COLOR_TEXT = Object.freeze([...DOMTemplateCells].map((DOMCell) => DOMCell.dataset.color.toUpperCase()));
        const COLOR_ID = Object.freeze(createEnum(...COLOR_TEXT));

        // 進捗
        const PASS_MAX = Math.trunc(PARAMETERS.BOARD_WIDTH+PARAMETERS.BOARD_HEIGHT)/2;  // あり得る最大パス回数
        const GAME_PROGRESS_MAX = PARAMETERS.BOARD_WIDTH*PARAMETERS.BOARD_HEIGHT + PASS_MAX;  // 終局
        let gameProgress = 0;  // 試合進捗

        let board = [];  // 盤面
        let scoreBoard = [];  // 盤面評価値
        let virtualBoard = [];  // AI先読み用盤面
        let weightBoard = [];  // 枚数重み付け
        let turn = 0;  // 手番
        let isOnAssist = false;  // アシスト表示中するかどうか
        let isOnHint = false;  // ヒント表示中するかどうか
        let isOnInput = false;  // パラメータ変更済みかどうか
        let isGameOver = false;  // ゲームオーバーかどうか
        let isPassed = false;  // パスかどうか
        let isAITurn = false;  // AIが操作中かどうか
        let isOnlyAI = false;  // AIvsAIかどうか
        let record = "";  // 棋譜(黒白のみ)
        let intervalID = 0;  // タイマーのclear用
        let INIT_AREA = {};  // 初期配置端点

        // エントリー
        main();

        /** メイン */
        function main() {
            // console.group("main");  // デバッグ用

            const DOMParameterArea = document.querySelector("details#parameter-area");  // バブリング用

            let isFocusedAny = false;  // フォーカス中かどうか

            // モバイル端末用設定
            setMobileDevice();

            // 初期化全般
            scroll(0, 0);
            defineParameter();
            onReset();

            // パラメータ設定検証
            DOMParameterArea.addEventListener("input", () => {
                // console.group("parameter-area input");  // デバッグ用

                initialize();

                if (!isOnInput) {
                    isOnInput = true;
                    // 無効化
                    isAITurn = true;  // onCellPut用
                    DOMAssist.disabled = true;
                    DOMHint.disabled = true;
                }

                // console.groupEnd("parameter-area input");  // デバッグ用
            });

            // パラメータ設定確定
            DOMEnter.addEventListener("click", async () => {
                // console.group("enter click");  // デバッグ用

                await onEnter();

                // console.groupEnd("enter click");  // デバッグ用
            });

            // リセット
            DOMReset.addEventListener("click", () => {
                // console.group("reset click");  // デバッグ用

                // 対局中なら確認を求める
                const isInGame = DOMEnter.disabled && !isGameOver;
                if (isInGame) {
                    if (!confirm("Realy reset?")) return;
                    // if (prompt("Realy reset?", "yes") !== "yes") return;
                }

                onReset();
                if (isInGame) {
                    console.log("This game was reset.");  // ログ用
                    DOMMessage.textContent = "This game was reset.";
                }

                // console.groupEnd("reset click");  // デバッグ用
            });

            // アシスト表示/非表示
            DOMAssist.addEventListener("click", async () => {
                // console.group("assist click");  // デバッグ用

                if (!isOnInput) {
                    isOnInput = true;
                    await onEnter();
                }

                onAssist(turn, !isOnAssist);

                // console.groupEnd("assist click");  // デバッグ用
            });

            // ヒント表示/非表示
            DOMHint.addEventListener("click", async () => {
                // console.group("hint click");  // デバッグ用

                if (!isOnInput) {
                    isOnInput = true;
                    await onEnter();
                }

                onHint(!isOnHint);

                // console.groupEnd("hint click");  // デバッグ用
            });

            // フォーカスを当てる
            DOMParameterArea.addEventListener("focusin", (event) => {
                // console.group("parameter-area focusin");  // デバッグ用

                const isFocusabled = event.target.matches('input:is([type="text"], [type="number"]), textarea');
                // console.log({isFocusabled});  // デバッグ用
                if (!isFocusabled) return;

                isFocusedAny = true;

                // console.groupEnd("parameter-area focusin");  // デバッグ用
            });

            // フォーカスを外す
            DOMParameterArea.addEventListener("focusout", () => {
                // console.group("parameter-area focusout");  // デバッグ用

                isFocusedAny = false;

                // console.groupEnd("parameter-area focusout");  // デバッグ用
            });

            // ショートカットキー設定
            window.addEventListener("keyup", (event) => {
                // console.group(`window keyup ${event.key}`);  // デバッグ用

                // console.log({isFocusedAny});  // デバッグ用

                // フォーカス中なら無効
                if (isFocusedAny) return;

                const clickEvent = new Event("click");
                switch (event.key) {
                    case "e": // パラメータ設定確定
                        if (!DOMEnter.disabled) {
                            DOMEnter.dispatchEvent(clickEvent);
                        }
                        break;
                    case "r": // リセット
                        if (!DOMReset.disabled) {
                            DOMReset.dispatchEvent(clickEvent);
                        }
                        break;
                    case "p": // パラメータ設定アコーディオン開閉
                        DOMParameterArea.open = !DOMParameterArea.open;
                        break;
                    case "/": // 最上位のウィジェットにフォーカス
                        const DOMFirstWidget = document.querySelector(":is(input, textarea, button, select):not(:disabled)");
                        const DOMDetails = DOMFirstWidget.parentElement;
                        if (DOMDetails.matches("details")) {
                            DOMDetails.open = true;
                        }
                        DOMFirstWidget.focus();
                        break;
                    case "a": // アシスト表示
                        if (!DOMAssist.disabled) {
                            DOMAssist.dispatchEvent(clickEvent);
                        }
                        break;
                    case "h": // ヒント表示
                        if (!DOMHint.disabled) {
                            DOMHint.dispatchEvent(clickEvent);
                        }
                        break;
                    case "Escape": // アシスト,ヒント非表示
                        if (isOnAssist) {
                            onAssist(turn, false);
                        }
                        if (isOnHint) {
                            onHint(false);
                        }
                        break;
                    default:
                        break;
                }

                // console.groupEnd(`window keyup ${event.key}`);  // デバッグ用
            });

            // ウィンドウ離脱抑止
            window.addEventListener("beforeunload", (event) => {
                // console.group("window beforeunload");  // デバッグ用

                // 対局中でないなら確認を求めない
                if (!DOMEnter.disabled || isGameOver) return;

                event.preventDefault();
                event.returnValue = "";
                return "";

                // console.groupEnd("window beforeunload");  // デバッグ用
            });

            // console.groupEnd("main");  // デバッグ用
        }

        /** モバイル端末用設定 */
        function setMobileDevice() {
            // console.group("setMobileDevice");  // デバッグ用

            const DOMHeader = document.querySelector("header");
            const DOMAside = document.querySelector("aside");
            const DOMFooter = document.querySelector("footer");
            const DOMInputNumberList = document.querySelectorAll('input[type="number"]');
            const regExpMobile = /(iPhone|Android).+Mobile/;
            const queryMobile = "(orientation: portrait) and (max-width: 560px)";
            if (regExpMobile.test(navigator.userAgent) || matchMedia(queryMobile).matches) {
                DOMHeader.classList.replace("shown", "hidden");
                DOMAside.classList.replace("shown", "hidden");
                DOMFooter.classList.replace("shown", "hidden");
                DOMInputNumberList.forEach((DOMInput) => {
                    DOMInput.type = "text";
                    DOMInput.inputMode = "numeric";
                    DOMInput.pattern = "^([1-9][0-9]*|0)$";
                });
            }

            // console.groupEnd("setMobileDevice");  // デバッグ用
        }

        /** リセット */
        function onReset() {
            // console.group("onReset");  // デバッグ用

            // AI停止
            clearInterval(intervalID);

            DOMTurn.classList.replace("hidden", "shown");
            DOMMessage.classList.replace("hidden", "shown");
            DOMWait.classList.replace("shown", "hidden");
            DOMResult.classList.replace("shown", "hidden");
            DOMRecord.classList.replace("shown", "hidden");

            initialize();
            isOnInput = false;
            isAITurn = false;

            // 有効化
            for (let [key, DOM_PARAMETER] of Object.entries(DOM_PARAMETERS)) {
                if (key === "AI_LIST") continue;
                if (DOM_PARAMETER.matches("option")) {
                    DOM_PARAMETER = DOM_PARAMETER.parentElement;  // select
                }
                DOM_PARAMETER.disabled = false;
            }
            DOM_PARAMETERS.AI_LIST.forEach((DOM_AI_COLOR) => {
                DOM_AI_COLOR.disabled = false;
            });
            const DOM_AI_LIST = document.querySelector("ul#AI_LIST");
            DOM_AI_LIST.classList.remove("disabled");
            DOMEnter.disabled = false;

            // console.groupEnd("onReset");  // デバッグ用
        }

        /** 初期化群 */
        function initialize() {
            // console.group("initialize");  // デバッグ用

            if (validateParameter()) {
                init();
                if (!PARAMETERS.HAND_MODE) {
                    setInitBoard();
                }
                setScoreBoard();
                setWeightBoard();
                createBoard();
            }

            // console.groupEnd("initialize");  // デバッグ用
        }

        /** パラメータ既定値設定 */
        function defineParameter() {
            // console.group("defineParameter");  // デバッグ用

            for (let [key, DOM_PARAMETER] of Object.entries(DOM_PARAMETERS)) {
                if (key === "AI_LIST") continue;
                if (DOM_PARAMETER.matches("select")) {
                    let selectIndex = 0;
                    if (key === "AI_LEVEL") {
                        selectIndex = DEFAULT_PARAMETERS[key];
                    }
                    if (key === "DELAY_MSEC") {
                        selectIndex = 2;
                    }
                    DOM_PARAMETER = DOM_PARAMETER.options[selectIndex];
                    DOM_PARAMETER.selected = true;
                    DOM_PARAMETER.textContent = String(DEFAULT_PARAMETERS[key]);
                    if (key === "DELAY_MSEC") {
                        DOM_PARAMETER.textContent += "ms";
                    }
                }
                if (DOM_PARAMETER.matches('input[type="checkbox"]')) {
                    DOM_PARAMETER.checked = DEFAULT_PARAMETERS[key];
                }
                DOM_PARAMETER.value = DEFAULT_PARAMETERS[key];
            }

            for (const DOM_AI_LIST of DOM_PARAMETERS.AI_LIST) {
                DOM_AI_LIST.checked = false;
            }
            for (const AIColor of DEFAULT_PARAMETERS.AI_LIST) {
                DOM_PARAMETERS.AI_LIST[AIColor-1].checked = true;
            }

            // console.groupEnd("defineParameter");  // デバッグ用
        }

        /** パラメータ設定検証 */
        function validateParameter() {
            // console.group("validateParameter");  // デバッグ用

            let isValidAll = true;  // すべて制約を満たすかどうか

            const regExpInt = /^([1-9][0-9]*|0)$/;  // 整数のみ可
            for (let [key, DOM_PARAMETER] of Object.entries(DOM_PARAMETERS)) {
                const value = Number(DOM_PARAMETER.value);
                let min = Number(DOM_PARAMETER.min);
                let max = Number(DOM_PARAMETER.max);
                let title = DOM_PARAMETER.title;
                const validity = DOM_PARAMETER.validity;

                if (key === "AI_LIST") continue;
                if (DOM_PARAMETER.matches("select")) {
                    PARAMETERS[key] = value;
                    continue;
                }

                if (DOM_PARAMETER.matches("input")) {
                    if (DOM_PARAMETER.matches('[type="checkbox"]')) {
                        PARAMETERS[key] = DOM_PARAMETER.checked;
                        continue;
                    } else {
                        min = Math.trunc(Math.log2(PARAMETERS.COLOR_NUM-1))*2 + 4;
                        title = `${min}以上${max}以下の整数を入力してください`;
                    }
                }

                DOM_PARAMETER.setCustomValidity("");
                if (validity.valid && regExpInt.test(String(value)) && min <= value && value <= max) {
                    PARAMETERS[key] = value;
                } else {
                    isValidAll = false;
                    DOM_PARAMETER.setCustomValidity("invalid");
                    if (validity.badInput) {
                        DOM_PARAMETER.setCustomValidity("invalid: badInput");
                    } else if (validity.valueMissing) {
                        DOM_PARAMETER.setCustomValidity("invalid: valueMissing");
                    } else if (validity.rangeOverflow || value > max) {
                        DOM_PARAMETER.setCustomValidity("invalid: rangeOverflow");
                    } else if (validity.rangeUnderflow || value < min) {
                        DOM_PARAMETER.setCustomValidity("invalid: rangeUnderflow");
                    } else if (validity.stepMismatch) {
                        DOM_PARAMETER.setCustomValidity("invalid: stepMismatch");
                    }
                }
                DOM_PARAMETER.reportValidity();
                DOM_PARAMETER.min = String(min);
                DOM_PARAMETER.max = String(max);
                DOM_PARAMETER.title = title;
            }

            PARAMETERS.AI_LIST = [];
            for (let i = 0; i < DOM_PARAMETERS.AI_LIST.length; i++) {
                const DOMListItem = DOM_PARAMETERS.AI_LIST[i].parentElement;  // li
                DOMListItem.classList.replace("hidden", "shown");
                if (i >= PARAMETERS.COLOR_NUM) {
                    DOMListItem.classList.replace("shown", "hidden");
                    DOM_PARAMETERS.AI_LIST[i].checked = false;
                }
                if (DOM_PARAMETERS.AI_LIST[i].checked) {
                    PARAMETERS.AI_LIST.push(i+1);
                }
            }
            const DOMListItem = DOM_PARAMETERS.AI_LEVEL.parentElement;  // li
            DOMListItem.classList.replace("hidden", "shown");
            if (PARAMETERS.AI_LIST.length === 0) {
                DOMListItem.classList.replace("shown", "hidden");
            }

            // パラメータのいずれかが制約を満たさないなら無効化
            DOMEnter.disabled = !isValidAll;

            // console.log(`DOM_PARAMETERS.DELAY_MSEC.value: ${DOM_PARAMETERS.DELAY_MSEC.value}`);  // デバッグ用
            // console.groupEnd("validateParameter");  // デバッグ用

            return isValidAll;
        }

        /** 初期化 */
        function init() {
            // console.group("init");  // デバッグ用

            // DOMTurn.textContent = "";
            DOMMessage.textContent = "";
            DOMResult.textContent = "";
            DOMRecord.textContent = "";

            board = new Array(PARAMETERS.BOARD_HEIGHT+2);
            for (let y = 0; y < PARAMETERS.BOARD_HEIGHT+2; y++) {
                board[y] = new Array(PARAMETERS.BOARD_WIDTH+2).fill(COLOR_ID.NONE);  // 外周は番兵
            }
            scoreBoard = structuredClone(board);
            virtualBoard = structuredClone(board);
            weightBoard = structuredClone(board);
            DOMBoardCells = structuredClone(board);

            isOnlyAI = false;  // プレイヤーvsプレイヤー
            if (PARAMETERS.AI_LIST.length === PARAMETERS.COLOR_NUM) {  // AIvsAI
                isOnlyAI = true;
                PARAMETERS.COLOR_NUM++;  // 番兵プレイヤー
            }

            /*
            // 途中結果表示  // デバッグ用
            let result = "";
            for (let c = COLOR_ID.NONE; c <= PARAMETERS.COLOR_NUM; c++) {
                result += `${COLOR_TEXT[c]}: ${colorCount(c)}\n`;
            }
            DOMResult.textContent = result;
            */

            // 先手
            turn = COLOR_ID.BLACK;
            DOMTurn.textContent = COLOR_TEXT[turn];
            DOMTurn.dataset.color = COLOR_TEXT[turn].toLowerCase();

            isOnAssist = false;
            isOnHint = false;
            // isOnInput = false;
            isGameOver = false;
            isPassed = false;
            // isAITurn = false;
            record = "";
            gameProgress = 0;
            INIT_AREA = (() => {
                const x = Math.trunc(PARAMETERS.BOARD_WIDTH/2);
                const y = Math.trunc(PARAMETERS.BOARD_HEIGHT/2);
                const w = Number(DOM_PARAMETERS.BOARD_WIDTH.min)-2;
                const h = Number(DOM_PARAMETERS.BOARD_HEIGHT.min)-2;
                return Object.freeze({
                    NORTH: y-Math.trunc(h/2) + 1,
                    WEST : x-Math.trunc(w/2) + 1,
                    SOUTH: y-Math.trunc(h/2) + h,
                    EAST : x-Math.trunc(w/2) + w,
                });
            })();

            // 最短パス(8x8) https://www.hasera.net/othello/mame006.html
            /*
            board[3][4] = COLOR_ID.BLACK;
            board[4][4] = COLOR_ID.BLACK;
            board[4][5] = COLOR_ID.BLACK;
            board[5][4] = COLOR_ID.BLACK;
            board[5][5] = COLOR_ID.BLACK;
            board[5][6] = COLOR_ID.BLACK;
            board[6][6] = COLOR_ID.BLACK;
            board[5][7] = COLOR_ID.WHITE;
            board[4][8] = COLOR_ID.WHITE;
            board[5][8] = COLOR_ID.WHITE;
            board[6][8] = COLOR_ID.WHITE;
            board[7][6] = COLOR_ID.BLACK;
            turn = COLOR_ID.WHITE;
            changeTurn();
            // black プレイヤー is パス
            */

            /*
            board[3][4] = COLOR_ID.BLACK;
            board[4][4] = COLOR_ID.BLACK;
            board[4][5] = COLOR_ID.BLACK;
            board[5][4] = COLOR_ID.BLACK;
            board[5][5] = COLOR_ID.BLACK;
            board[5][6] = COLOR_ID.BLACK;
            board[6][6] = COLOR_ID.BLACK;
            board[5][7] = COLOR_ID.WHITE;
            board[4][8] = COLOR_ID.WHITE;
            board[5][8] = COLOR_ID.BLACK;
            // board[6][8] = COLOR_ID.WHITE  // プレイヤー
            board[7][6] = COLOR_ID.BLACK;
            turn = COLOR_ID.BLACK;
            changeTurn();
            // black AI is パス
            */

            // 最短5連続パス(8x8) https://www.hasera.net/othello/mame007.html
            /*
            board[4][3] = COLOR_ID.BLACK;
            board[4][4] = COLOR_ID.BLACK;
            board[4][5] = COLOR_ID.BLACK;
            board[5][4] = COLOR_ID.BLACK;
            board[5][5] = COLOR_ID.BLACK;
            board[5][6] = COLOR_ID.BLACK;
            board[5][7] = COLOR_ID.BLACK;
            board[5][8] = COLOR_ID.BLACK;
            board[6][6] = COLOR_ID.WHITE;
            board[6][8] = COLOR_ID.WHITE;
            board[7][4] = COLOR_ID.BLACK;
            board[7][5] = COLOR_ID.BLACK;
            board[7][6] = COLOR_ID.BLACK;
            board[7][7] = COLOR_ID.BLACK;
            board[7][8] = COLOR_ID.WHITE;
            board[8][8] = COLOR_ID.WHITE;
            turn = COLOR_ID.BLACK;
            changeTurn();
            // board[8][6] = COLOR_ID.WHITE  // プレイヤー
            // board[8][4] = COLOR_ID.WHITE  // プレイヤー
            // board[7][3] = COLOR_ID.WHITE  // プレイヤー
            // board[4][8] = COLOR_ID.WHITE  // プレイヤー
            // black プレイヤー|AI is 5パス
            */

            // console.groupEnd("init");  // デバッグ用
        }

        /** 初期配置設定 */
        function setInitBoard() {
            // console.group("setInitBoard");  // デバッグ用

            let colorNum = PARAMETERS.COLOR_NUM;
            if (isOnlyAI) {
                colorNum--;
            }

            const CENTER4 = Object.freeze({  // 中心4点
                NORTH: Math.trunc(PARAMETERS.BOARD_HEIGHT/2),
                WEST : Math.trunc(PARAMETERS.BOARD_WIDTH /2),
                SOUTH: Math.trunc(PARAMETERS.BOARD_HEIGHT/2)+1,
                EAST : Math.trunc(PARAMETERS.BOARD_WIDTH /2)+1,
            });
            switch (colorNum) {
                case 2:
                    board[CENTER4.NORTH][CENTER4.WEST] = COLOR_ID.WHITE;
                    board[CENTER4.NORTH][CENTER4.EAST] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH][CENTER4.WEST] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH][CENTER4.EAST] = COLOR_ID.WHITE;
                    break;
                case 3:
                    board[CENTER4.NORTH-1][CENTER4.WEST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.WEST-1] = COLOR_ID.RED;
                    board[CENTER4.NORTH  ][CENTER4.WEST  ] = COLOR_ID.WHITE;

                    board[CENTER4.NORTH-1][CENTER4.EAST  ] = COLOR_ID.RED;
                    board[CENTER4.NORTH  ][CENTER4.EAST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.EAST+1] = COLOR_ID.WHITE;

                    board[CENTER4.SOUTH  ][CENTER4.WEST-1] = COLOR_ID.WHITE;
                    board[CENTER4.SOUTH  ][CENTER4.WEST  ] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH+1][CENTER4.WEST  ] = COLOR_ID.RED;

                    board[CENTER4.SOUTH  ][CENTER4.EAST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH  ][CENTER4.EAST+1] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH+1][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    break;
                case 4:
                    board[CENTER4.NORTH-1][CENTER4.WEST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.WEST  ] = COLOR_ID.WHITE;
                    board[CENTER4.NORTH  ][CENTER4.EAST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.EAST+1] = COLOR_ID.BLUE;
                    board[CENTER4.SOUTH  ][CENTER4.WEST-1] = COLOR_ID.WHITE;
                    board[CENTER4.SOUTH  ][CENTER4.WEST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH  ][CENTER4.EAST  ] = COLOR_ID.BLUE;
                    board[CENTER4.SOUTH+1][CENTER4.EAST  ] = COLOR_ID.RED;
                    break;
                case 5:
                    board[CENTER4.NORTH-2][CENTER4.WEST  ] = COLOR_ID.CYAN;
                    board[CENTER4.NORTH-1][CENTER4.WEST-1] = COLOR_ID.BLUE;
                    board[CENTER4.NORTH-1][CENTER4.WEST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.WEST-1] = COLOR_ID.RED;
                    board[CENTER4.NORTH  ][CENTER4.WEST  ] = COLOR_ID.WHITE;

                    board[CENTER4.NORTH-1][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    board[CENTER4.NORTH-1][CENTER4.EAST+1] = COLOR_ID.RED;
                    board[CENTER4.NORTH  ][CENTER4.EAST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.EAST+1] = COLOR_ID.CYAN;
                    board[CENTER4.NORTH  ][CENTER4.EAST+2] = COLOR_ID.BLUE;

                    board[CENTER4.SOUTH  ][CENTER4.WEST-2] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH  ][CENTER4.WEST-1] = COLOR_ID.WHITE;
                    board[CENTER4.SOUTH  ][CENTER4.WEST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH+1][CENTER4.WEST-1] = COLOR_ID.CYAN;
                    board[CENTER4.SOUTH+1][CENTER4.WEST  ] = COLOR_ID.BLUE;

                    board[CENTER4.SOUTH  ][CENTER4.EAST  ] = COLOR_ID.BLUE;
                    board[CENTER4.SOUTH  ][CENTER4.EAST+1] = COLOR_ID.CYAN;
                    board[CENTER4.SOUTH+1][CENTER4.EAST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH+1][CENTER4.EAST+1] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH+2][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    break;
                case 6:
                    board[CENTER4.NORTH-2][CENTER4.WEST-1] = COLOR_ID.CYAN;
                    board[CENTER4.NORTH-2][CENTER4.WEST  ] = COLOR_ID.MAGENTA;
                    board[CENTER4.NORTH-1][CENTER4.WEST-1] = COLOR_ID.BLUE;
                    board[CENTER4.NORTH-1][CENTER4.WEST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.WEST-1] = COLOR_ID.RED;
                    board[CENTER4.NORTH  ][CENTER4.WEST  ] = COLOR_ID.WHITE;

                    board[CENTER4.NORTH-1][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    board[CENTER4.NORTH-1][CENTER4.EAST+1] = COLOR_ID.RED;
                    board[CENTER4.NORTH-1][CENTER4.EAST+2] = COLOR_ID.BLUE;
                    board[CENTER4.NORTH  ][CENTER4.EAST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.EAST+1] = COLOR_ID.MAGENTA;
                    board[CENTER4.NORTH  ][CENTER4.EAST+2] = COLOR_ID.CYAN;

                    board[CENTER4.SOUTH  ][CENTER4.WEST-2] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH  ][CENTER4.WEST-1] = COLOR_ID.WHITE;
                    board[CENTER4.SOUTH  ][CENTER4.WEST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH+1][CENTER4.WEST-2] = COLOR_ID.MAGENTA;
                    board[CENTER4.SOUTH+1][CENTER4.WEST-1] = COLOR_ID.CYAN;
                    board[CENTER4.SOUTH+1][CENTER4.WEST  ] = COLOR_ID.BLUE;

                    board[CENTER4.SOUTH  ][CENTER4.EAST  ] = COLOR_ID.BLUE;
                    board[CENTER4.SOUTH  ][CENTER4.EAST+1] = COLOR_ID.CYAN;
                    board[CENTER4.SOUTH+1][CENTER4.EAST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH+1][CENTER4.EAST+1] = COLOR_ID.MAGENTA;
                    board[CENTER4.SOUTH+2][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    board[CENTER4.SOUTH+2][CENTER4.EAST+1] = COLOR_ID.BLACK;
                    break;
                case 7:
                    board[CENTER4.NORTH-2][CENTER4.WEST  ] = COLOR_ID.YELLOW;
                    board[CENTER4.NORTH-1][CENTER4.WEST-2] = COLOR_ID.CYAN;
                    board[CENTER4.NORTH-1][CENTER4.WEST-1] = COLOR_ID.MAGENTA;
                    board[CENTER4.NORTH-1][CENTER4.WEST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.WEST-2] = COLOR_ID.BLUE;
                    board[CENTER4.NORTH  ][CENTER4.WEST-1] = COLOR_ID.RED;
                    board[CENTER4.NORTH  ][CENTER4.WEST  ] = COLOR_ID.WHITE;

                    board[CENTER4.NORTH-2][CENTER4.EAST  ] = COLOR_ID.RED;
                    board[CENTER4.NORTH-2][CENTER4.EAST+1] = COLOR_ID.BLUE;
                    board[CENTER4.NORTH-1][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    board[CENTER4.NORTH-1][CENTER4.EAST+1] = COLOR_ID.CYAN;
                    board[CENTER4.NORTH  ][CENTER4.EAST  ] = COLOR_ID.BLACK;
                    board[CENTER4.NORTH  ][CENTER4.EAST+1] = COLOR_ID.YELLOW;
                    board[CENTER4.NORTH  ][CENTER4.EAST+2] = COLOR_ID.MAGENTA;

                    board[CENTER4.SOUTH  ][CENTER4.WEST-2] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH  ][CENTER4.WEST-1] = COLOR_ID.WHITE;
                    board[CENTER4.SOUTH  ][CENTER4.WEST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH+1][CENTER4.WEST-1] = COLOR_ID.YELLOW;
                    board[CENTER4.SOUTH+1][CENTER4.WEST  ] = COLOR_ID.BLUE;
                    board[CENTER4.SOUTH+2][CENTER4.WEST-1] = COLOR_ID.MAGENTA;
                    board[CENTER4.SOUTH+2][CENTER4.WEST  ] = COLOR_ID.CYAN;

                    board[CENTER4.SOUTH  ][CENTER4.EAST  ] = COLOR_ID.BLUE;
                    board[CENTER4.SOUTH  ][CENTER4.EAST+1] = COLOR_ID.CYAN;
                    board[CENTER4.SOUTH  ][CENTER4.EAST+1] = COLOR_ID.MAGENTA;
                    board[CENTER4.SOUTH+1][CENTER4.EAST  ] = COLOR_ID.RED;
                    board[CENTER4.SOUTH+1][CENTER4.EAST+1] = COLOR_ID.BLACK;
                    board[CENTER4.SOUTH+1][CENTER4.EAST+2] = COLOR_ID.YELLOW;
                    board[CENTER4.SOUTH+2][CENTER4.EAST  ] = COLOR_ID.WHITE;
                    break;
                default:
                    exit();
                    break;
            }

            // console.groupEnd("setInitBoard");  // デバッグ用
        }

        /** AI思考基準評価値設定 */
        function setScoreBoard() {
            // console.group("setScoreBoard");  // デバッグ用

            const BOARD_WIDTH  = PARAMETERS.BOARD_WIDTH;
            const BOARD_HEIGHT = PARAMETERS.BOARD_HEIGHT;
            const BOARD_MAX = (BOARD_WIDTH >  BOARD_HEIGHT) ?BOARD_WIDTH :BOARD_HEIGHT;
            const BOARD_MIN = (BOARD_WIDTH <= BOARD_HEIGHT) ?BOARD_WIDTH :BOARD_HEIGHT;
            const BOARD_MAX_HALF = Math.trunc(BOARD_MAX/2);
            const BOARD_MIN_HALF = Math.trunc(BOARD_MIN/2);

            const SCORE_MIN = 0;
            const SCORE_MAX = BOARD_MAX_HALF+3;
            // 外周は番兵
            for (let x = 0; x <= BOARD_WIDTH+1; x++) {
                scoreBoard[0             ][x] = SCORE_MIN;
                scoreBoard[BOARD_HEIGHT+1][x] = SCORE_MIN;
            }
            for (let y = 0; y <= BOARD_HEIGHT+1; y++) {
                scoreBoard[y][0            ] = SCORE_MIN;
                scoreBoard[y][BOARD_WIDTH+1] = SCORE_MIN;
            }

            /* 名前(8x8)
                隅 Ⅽ Ａ Ｂ Ｂ Ａ Ⅽ 隅
                Ⅽ Ｘ 辺 辺 辺 辺 Ｘ Ⅽ
                Ａ 辺 Ｘ 辺 辺 Ｘ 辺 Ａ
                Ｂ 辺 辺 初 初 辺 辺 Ｂ
                Ｂ 辺 辺 初 初 辺 辺 Ｂ
                Ａ 辺 Ｘ 辺 辺 Ｘ 辺 Ａ
                Ⅽ Ｘ 辺 辺 辺 辺 Ｘ Ⅽ
                隅 Ⅽ Ａ Ｂ Ｂ Ａ Ⅽ 隅
            */
            /* 評価値(8x8)
                7  2  6  5  5  6  2  7
                2  1  3  3  3  3  1  2
                6  3  6  4  4  6  3  6
                5  3  4  0  0  4  3  5
                5  3  4  0  0  4  3  5
                6  3  6  4  4  6  3  6
                2  1  3  3  3  3  1  2
                7  2  6  5  5  6  2  7
            */

            // i: 外周から数えて何番目
            // i === 0: 外周

            // i === 1

            // 隅
            const SCORE_CORNER = SCORE_MAX;
            scoreBoard[1           ][1          ] = SCORE_CORNER;
            scoreBoard[1           ][BOARD_WIDTH] = SCORE_CORNER;
            scoreBoard[BOARD_HEIGHT][1          ] = SCORE_CORNER;
            scoreBoard[BOARD_HEIGHT][BOARD_WIDTH] = SCORE_CORNER;

            // Ａ
            const SCORE_A = SCORE_CORNER-1;
            scoreBoard[1             ][3            ] = SCORE_A;
            scoreBoard[1             ][BOARD_WIDTH-2] = SCORE_A;
            scoreBoard[3             ][1            ] = SCORE_A;
            scoreBoard[3             ][BOARD_WIDTH  ] = SCORE_A;
            scoreBoard[BOARD_HEIGHT-2][1            ] = SCORE_A;
            scoreBoard[BOARD_HEIGHT-2][BOARD_WIDTH  ] = SCORE_A;
            scoreBoard[BOARD_HEIGHT  ][3            ] = SCORE_A;
            scoreBoard[BOARD_HEIGHT  ][BOARD_WIDTH-2] = SCORE_A;

            // Ｂ
            const SCORE_B = SCORE_A-1;
            for (let x = 4; x <= BOARD_WIDTH-3; x++) {
                scoreBoard[1           ][x] = SCORE_B;
                scoreBoard[BOARD_HEIGHT][x] = SCORE_B;
            }
            for (let y = 4; y <= BOARD_HEIGHT-3; y++) {
                scoreBoard[y][1          ] = SCORE_B;
                scoreBoard[y][BOARD_WIDTH] = SCORE_B;
            }

            // Ⅽ
            const SCORE_C = SCORE_MIN+1;;
            scoreBoard[1             ][2            ] = SCORE_C;
            scoreBoard[1             ][BOARD_WIDTH-1] = SCORE_C;
            scoreBoard[2             ][1            ] = SCORE_C;
            scoreBoard[2             ][BOARD_WIDTH  ] = SCORE_C;
            scoreBoard[BOARD_HEIGHT-1][1            ] = SCORE_C;
            scoreBoard[BOARD_HEIGHT-1][BOARD_WIDTH  ] = SCORE_C;
            scoreBoard[BOARD_HEIGHT  ][2            ] = SCORE_C;
            scoreBoard[BOARD_HEIGHT  ][BOARD_WIDTH-1] = SCORE_C;

            for (let i = 2; i <= BOARD_MIN_HALF; i++) {
                // Ｘ
                const iHalf = Math.trunc(i/2);
                let SCORE_STAR = (i%2 === 0) ?iHalf :SCORE_CORNER-iHalf;
                SCORE_STAR = (SCORE_STAR === SCORE_C) ?SCORE_C+1 :SCORE_STAR;
                scoreBoard[i               ][i              ] = SCORE_STAR;
                scoreBoard[i               ][BOARD_WIDTH-i+1] = SCORE_STAR;
                scoreBoard[BOARD_HEIGHT-i+1][i              ] = SCORE_STAR;
                scoreBoard[BOARD_HEIGHT-i+1][BOARD_WIDTH-i+1] = SCORE_STAR;

                // 辺
                const SCORE_MID = (i%2 === 0) ?SCORE_C+1+iHalf :SCORE_B-iHalf;
                for (let x = i+1; x <= BOARD_WIDTH-i; x++) {
                    scoreBoard[i               ][x] = SCORE_MID;
                    scoreBoard[BOARD_HEIGHT-i+1][x] = SCORE_MID;
                }
                for (let y = i+1; y <= BOARD_HEIGHT-i; y++) {
                    scoreBoard[y][i              ] = SCORE_MID;
                    scoreBoard[y][BOARD_WIDTH-i+1] = SCORE_MID;
                }
            }

            // http://www.net.c.dendai.ac.jp/~ksuzuki/
            /*
            scoreBoard = [
                [-99, -99, -99, -99, -99, -99, -99, -99, -99, -99],
                [-99, 120, -20,  20,   5,   5,  20, -20, 120, -99],
                [-99, -20, -40,  -5,  -5,  -5,  -5, -40, -20, -99],
                [-99,  20,  -5,  15,   3,   3,  15,  -5,  20, -99],
                [-99,   5,  -5,   3,   3,   3,   3,  -5,   5, -99],
                [-99,   5,  -5,   3,   3,   3,   3,  -5,   5, -99],
                [-99,  20,  -5,  15,   3,   3,  15,  -5,  20, -99],
                [-99, -20, -40,  -5,  -5,  -5,  -5, -40, -20, -99],
                [-99, 120, -20,  20,   5,   5,  20, -20, 120, -99],
                [-99, -99, -99, -99, -99, -99, -99, -99, -99, -99],
            ];
            */

            // console.table(scoreBoard);  // デバッグ用
            // console.groupEnd("setScoreBoard");  // デバッグ用
        }

        /** 枚数重み付け設定 */
        function setWeightBoard() {
            // console.group("setWeightBoard");  // デバッグ用

            // 既定値
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    weightBoard[y][x] = 1;
                }
            }

            if (!PARAMETERS.LUCKY_MODE) return;

            const luckyWeight = randomIntRange(4, 10);
            console.log(`luckyWeight: ${luckyWeight}`);  // ログ用
            const totalNum = PARAMETERS.BOARD_WIDTH*PARAMETERS.BOARD_HEIGHT;
            const luckyNum = randomIntRange(1, Math.trunc(totalNum/8));
            let n = 0;
            while (n < luckyNum) {
                const luckyX = randomIntRange(1, PARAMETERS.BOARD_WIDTH);
                const luckyY = randomIntRange(1, PARAMETERS.BOARD_HEIGHT);
                if (weightBoard[luckyY][luckyX] > 1) continue;
                weightBoard[luckyY][luckyX] = luckyWeight;
                n++;
            }

            // console.groupEnd("setWeightBoard");  // デバッグ用
        }

        /** 描画用盤面生成 */
        function createBoard() {
            // console.group("createBoard");  // デバッグ用

            while (DOMBoard.firstChild) {
                DOMBoard.removeChild(DOMBoard.firstChild);
            }
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    const DOMCell = DOMTemplateCells[board[y][x]].cloneNode(true);

                    // 1次元座標付与
                    DOMCell.dataset.index = String(xyToIndex(x, y));
                    // 評価値付与
                    DOMCell.querySelector("text").textContent = String(scoreBoard[y][x]);
                    // ラッキーマス色付与
                    if (weightBoard[y][x] > 1) {
                        DOMCell.classList.add("lucky");
                    }
                    // 初期配置手動時範囲外判定
                    if (PARAMETERS.HAND_MODE
                    && !checkInsideBoard(x, y, INIT_AREA.WEST, INIT_AREA.EAST, INIT_AREA.NORTH, INIT_AREA.SOUTH)) {
                        DOMCell.classList.add("not-init_area");
                    }
                    // クリックによる着手位置指定登録
                    DOMCell.addEventListener("click", () => {
                        onCellPut(x, y);
                    });

                    DOMBoard.appendChild(DOMCell);
                    DOMBoardCells[y][x] = DOMBoard.querySelector(`svg[data-index="${xyToIndex(x, y)}"]`);
                }
                const DOMTextBR = document.createElement("br");
                DOMBoard.appendChild(DOMTextBR);
            }

            // console.groupEnd("createBoard");  // デバッグ用
        }

        /** パラメータ設定確定 */
        async function onEnter() {
            // console.group("onEnter");  // デバッグ用

            // 有効化
            isAITurn = false;  // onCellPut用
            DOMAssist.disabled = false;
            DOMHint.disabled = false;

            // 無効化
            for (let [key, DOM_PARAMETER] of Object.entries(DOM_PARAMETERS)) {
                if (key === "AI_LIST") continue;
                if (DOM_PARAMETER.matches("option")) {
                    DOM_PARAMETER = DOM_PARAMETER.parentElement;  // select
                }
                DOM_PARAMETER.disabled = true;
            }
            DOM_PARAMETERS.AI_LIST.forEach((DOM_AI_COLOR) => {
                DOM_AI_COLOR.disabled = true;
            });
            const DOM_AI_LIST = document.querySelector("ul#AI_LIST");
            DOM_AI_LIST.classList.add("disabled");
            DOMEnter.disabled = true;

            console.log("This game was began.");  // ログ用
            DOMMessage.textContent = "This game was began.";

            await AIListPut();  // 先手AI

            // console.groupEnd("onEnter");  // デバッグ用
        }

        /** アシスト表示
         * @param {number} [color=turn] 手番
         * @param {boolean} [isOn=true] 表示するかどうか
         * @returns {boolean} 表示中かどうか
         */
        function onAssist(color = turn, isOn = true) {
            // console.group("onAssist");  // デバッグ用

            const DOMAssistCell = DOMTemplateAssists[color].cloneNode(true);
            const assistCellClass = DOMAssistCell.getAttribute("class");

            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    const DOMBoardCell = DOMBoardCells[y][x];
                    if (isOn) {  // 表示
                        if (!checkCanPut(x, y)) continue;
                        DOMBoardCell.setAttribute("class", assistCellClass);
                        DOMBoardCell.dataset.color = DOMAssistCell.dataset.color;
                        DOMBoardCell.innerHTML = DOMAssistCell.innerHTML;
                    } else {  // 非表示
                        const DOMCell = DOMTemplateCells[board[y][x]].cloneNode(true);
                        const boardCellClass = DOMBoardCell.getAttribute("class");
                        const cellClass = DOMCell.getAttribute("class");
                        if (boardCellClass !== assistCellClass) continue;
                        DOMBoardCell.setAttribute("class", cellClass);
                        DOMBoardCell.dataset.color = DOMCell.dataset.color;
                        DOMBoardCell.innerHTML = DOMCell.innerHTML;
                    }
                    const DOMScore = DOMBoardCell.querySelector("text");
                    DOMScore.textContent = String(scoreBoard[y][x]);
                    if (isOnHint) {
                        DOMScore.classList.replace("hidden", "shown");
                    }
                }
            }

            // console.groupEnd("onAssist");  // デバッグ用

            return isOnAssist = isOn;
        }

        /** ヒント表示
         * @param {boolean} [isOn=true] 表示するかどうか
         * @returns {boolean} 表示中かどうか
         */
        function onHint(isOn = true) {
            // console.group("onHint");  // デバッグ用

            const DOMScores = DOMBoard.querySelectorAll("svg > text");
            DOMScores.forEach((DOMScore) => {
                if (isOn) {
                    DOMScore.classList.replace("hidden", "shown");
                } else {
                    DOMScore.classList.replace("shown", "hidden");
                }
            });

            // console.groupEnd("onHint");  // デバッグ用

            return isOnHint = isOn;
        }

        /** 盤面の2次元座標の1次元化
         * @param {number} x 盤面のx座標
         * @param {number} y 盤面のy座標
         * @param {number} [W=PARAMETERS.BOARD_WIDTH] 盤面の横幅
         * @returns {number} 盤面の1次元座標
         */
        function xyToIndex(x, y, W = PARAMETERS.BOARD_WIDTH) {
            // console.group("xyToIndex");  // デバッグ用

            const Nx = W+2;
            const index = y * Nx + x;

            // console.groupEnd("xyToIndex");  // デバッグ用
            return index;
        }

        /** 盤面の1次元座標の2次元化
         * @param {number} index 盤面の1次元座標
         * @param {number} [W=PARAMETERS.BOARD_WIDTH] 盤面の横幅
         * @returns {number[]} 盤面のx座標とy座標の組
         */
        function indexToXY(index, W = PARAMETERS.BOARD_WIDTH) {
            // console.group("indexToXY");  // デバッグ用

            const Nx = W+2;
            const x = index % Nx;
            const y = Math.trunc(index / Nx);

            // console.groupEnd("indexToXY");  // デバッグ用
            return [x, y];
        }

        /** 着手位置指定
         * @param {number} x 盤面のx座標
         * @param {number} y 盤面のy座標
         */
        async function onCellPut(x, y) {
            // console.group("onCellPut");  // デバッグ用

            // 無効化
            if (isGameOver || isAITurn || isPassed) return;

            // パラメータ設定確定
            if (!isOnInput) {
                isOnInput = true;
                await onEnter();
            }

            // 着手
            if (!checkCanPut(x, y, turn, true)) {
                DOMMessage.textContent = `Cannot put ${COLOR_TEXT[turn]} here.\n`;
                return;
            }
            DOMMessage.textContent = "";

            await changeTurn();
            await AIListPut();

            // console.groupEnd("onCellPut");  // デバッグ用
        }

        /** 着手可能位置判定
         * @param {number} x 盤面のx座標
         * @param {number} y 盤面のy座標
         * @param {number} [color=turn] 手番
         * @param {boolean} [isFlip=false] 実際に着手する(反転を行う)かどうか
         * @param {boolean} [isReal=true] 走査対象がboardかどうか
         * @returns {number} 反転可能個数
         */
        function checkCanPut(x, y, color = turn, isFlip = false, isReal = true) {
            // console.group("checkCanPut");  // デバッグ用

            const DOMBoardCell = DOMBoardCells[y][x];
            let countFlip = 0;  // 反転可能個数

            // 外周は着手不可
            if (!checkInsideBoard(x, y)) return 0;

            // 着手済みなら着手不可
            const board_yx = (isReal) ?board[y][x] :virtualBoard[y][x];
            if (board_yx > COLOR_ID.NONE) return 0;

            // 初期配置手動モード
            if (PARAMETERS.HAND_MODE) {
                if (checkInsideBoard(x, y, INIT_AREA.WEST, INIT_AREA.EAST, INIT_AREA.NORTH, INIT_AREA.SOUTH)) {
                    if (isFlip) {
                        if (isReal) {
                            onHighlightAllHide();
                            put(x, y, color);
                            const strXY = `${String.fromCharCode(x-1+"A".charCodeAt(0))}${y}`;
                            console.log(`turn: ${COLOR_TEXT[color]}, x: ${x}, y: ${y}, xy: ${strXY}`);  // ログ用
                            record += strXY;  // ログ用
                            onHighlight(x, y, color, true);
                            DOMBoardCell.querySelector("rect.highlight-stone").classList.add("highlight-put");
                        } else {
                            virtualBoard[y][x] = color;
                        }
                    }
                    return 1;
                } else {
                    return 0;
                }
            }

            let isFirstPut = true;  // 指定位置に置くのは1回だけ
            for (let dy = -1; dy <= 1; dy++) {  // 縦方向
                for (let dx = -1; dx <= 1; dx++) {  // 横方向
                    if (dx === 0 && dy === 0) continue;
                    let flipX = x+dx;  // 横隣接
                    let flipY = y+dy;  // 縦隣接
                    let flipN = 0;     // 挟んだ個数
                    let board_filpYX = (isReal) ?board[flipY][flipX] :virtualBoard[flipY][flipX];
                    while (! (board_filpYX === color || board_filpYX === COLOR_ID.NONE)) {  // 自色または外周に到達するまで
                        flipX += dx;
                        flipY += dy;
                        flipN++;
                        board_filpYX = (isReal) ?board[flipY][flipX] :virtualBoard[flipY][flipX];
                    }
                    if (flipN === 0 || board_filpYX === COLOR_ID.NONE) continue;
                    // 挟んでいるなら反転可能としてカウント
                    countFlip += flipN;

                    if (!isFlip) continue;
                    if (isFirstPut) {
                        if (isReal) {
                            isFirstPut = false;
                            // 全位置のハイライト非表示
                            onHighlightAllHide();
                            // 実際に着手する
                            put(x, y, color);
                            const strXY = `${String.fromCharCode(x-1+"A".charCodeAt(0))}${y}`;
                            console.log(`turn: ${COLOR_TEXT[color]}, x: ${x}, y: ${y}, xy: ${strXY}`);  // ログ用
                            record += strXY;  // ログ用
                            // 着手位置のハイライト表示
                            onHighlight(x, y, color, true);
                            DOMBoardCell.querySelector("rect.highlight-stone").classList.add("highlight-put");
                        } else {
                            virtualBoard[y][x] = color;
                        }
                    }

                    flipX = x+dx;
                    flipY = y+dy;
                    while (flipN > 0) {
                        if (isReal) {
                            // 実際に反転する
                            put(flipX, flipY, color);
                            // 反転位置のハイライト表示
                            onHighlight(flipX, flipY, color, true);
                        } else {
                            virtualBoard[flipY][flipX] = color;
                        }
                        flipX += dx;
                        flipY += dy;
                        flipN--;
                    }
                }
            }
            // console.groupEnd("checkCanPut");  // デバッグ用

            return countFlip;
        }

        /** 着手可能盤面判定(パスでないか判定)
         * @param {number} [color=turn] 手番
         * @returns {boolean} 着手可能な位置がある盤面かどうか
         */
        function checkCanPutAny(color = turn) {
            // console.group("checkCanPutAny");  // デバッグ用

            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    if (checkCanPut(x, y, color)) return true;
                }
            }

            // console.groupEnd("checkCanPutAny");  // デバッグ用

            return false;
        }

        /** 盤面範囲内判定
        * @param {number} x 盤面のx座標
        * @param {number} y 盤面のy座標
        * @param {number} [xFirst=1] x軸始点
        * @param {number} [xLast=PARAMETERS.BOARD_WIDTH] x軸終点
        * @param {number} [yFirst=1] y軸始点
        * @param {number} [yLast=PARAMETERS.BOARD_HEIGHT] y軸終点
        */
        function checkInsideBoard(x, y, xFirst = 1, xLast = PARAMETERS.BOARD_WIDTH,
                                        yFirst = 1, yLast = PARAMETERS.BOARD_HEIGHT) {
            const isInX = xFirst <= x && x <= xLast;
            const isInY = yFirst <= y && y <= yLast;
            return isInX && isInY;
        }

        /** 指定位置のハイライト表示
        * @param {number} x 盤面のx座標
        * @param {number} y 盤面のy座標
        * @param {number} [color=turn] 手番
        * @param {boolean} [isOn=true] 表示するかどうか
        * @returns {boolean} 表示中かどうか
        */
        function onHighlight(x, y, color = turn, isOn = true) {
            // console.group("onHighlight");  // デバッグ用

            if (!checkInsideBoard(x, y)) return;

            const DOMBoardCell = DOMBoardCells[y][x];
            const DOMCell = DOMTemplateCells[board[y][x]].cloneNode(true);
            const DOMHighlightCell = DOMTemplateHighlights[color].cloneNode(true);
            const cellClass = DOMCell.getAttribute("class");
            const highLightCellClass = DOMHighlightCell.getAttribute("class");

            if (isOn) {  // 表示
                DOMBoardCell.setAttribute("class", highLightCellClass);
                DOMBoardCell.dataset.color = DOMHighlightCell.dataset.color;
                DOMBoardCell.innerHTML = DOMHighlightCell.innerHTML;
            } else {  // 非表示
                DOMBoardCell.setAttribute("class", cellClass);
                DOMBoardCell.dataset.color = DOMCell.dataset.color;
                DOMBoardCell.innerHTML = DOMCell.innerHTML;
            }
            DOMBoardCell.querySelector("text").textContent = String(scoreBoard[y][x]);
            if (weightBoard[y][x] > 1) {
                DOMBoardCell.classList.add("lucky");
            }
            if (PARAMETERS.HAND_MODE
            && !checkInsideBoard(x, y, INIT_AREA.WEST, INIT_AREA.EAST, INIT_AREA.NORTH, INIT_AREA.SOUTH)) {
                DOMBoardCell.classList.add("not-init_area");
            }

            // console.groupEnd("onHighlight");  // デバッグ用

            return isOn;
        }

        /** 全位置のハイライト非表示 */
        function onHighlightAllHide() {
            // console.group("onHighlightAllHide");  // デバッグ用

            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    onHighlight(x, y, turn, false);
                }
            }

            // console.groupEnd("onHighlightAllHide");  // デバッグ用
        }

        /** 設置
        * @description 盤面の指定位置を指定色で上書き
        * @param {number} x 盤面のx座標
        * @param {number} y 盤面のy座標
        * @param {number} [color=turn] 手番
        */
        function put(x, y, color = turn) {
            // console.group("put");  // デバッグ用

            if (!checkInsideBoard(x, y)) return;

            board[y][x] = color;
            const DOMBoardCell = DOMBoardCells[y][x];
            const DOMCell = DOMTemplateCells[color].cloneNode(true);
            DOMBoardCell.dataset.color = DOMCell.dataset.color;
            DOMBoardCell.innerHTML = DOMCell.innerHTML;
            DOMBoardCell.querySelector("text").textContent = String(scoreBoard[y][x]);
            if (weightBoard[y][x] > 1) {
                DOMCell.classList.add("lucky");
            }
            if (PARAMETERS.HAND_MODE
            && !checkInsideBoard(x, y, INIT_AREA.WEST, INIT_AREA.EAST, INIT_AREA.NORTH, INIT_AREA.SOUTH)) {
                DOMCell.classList.add("not-init_area");
            }

            // console.groupEnd("put");  // デバッグ用
        }

        /** 手番変更 */
        async function changeTurn() {
            // console.group("changeTurn");  // デバッグ用

            // 番兵プレイヤー判定
            let isSentinelTurn = checkSentinelTurn(turn);

            // 進捗カウント
            if (!isSentinelTurn) {
                gameProgress++;
            }
            // console.log({gameProgress});  // デバッグ用

            // 初期配置手動モード継続判定
            if (PARAMETERS.HAND_MODE) {
                let colorNum = PARAMETERS.COLOR_NUM;
                if (isOnlyAI) {
                    colorNum--;
                }
                const initNum = 2;  // 各色の初期配置枚数
                const isHand = gameProgress < colorNum*initNum;
                // 各色置ききれば(初期配置終了すれば)通常着手モードに移行
                if (!isHand) {
                    for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                        for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                            const DOMCell = DOMBoardCells[y][x];
                            if (x < INIT_AREA.WEST  || INIT_AREA.EAST  < x
                            || y < INIT_AREA.NORTH || INIT_AREA.SOUTH < y) {
                                DOMCell.classList.remove("not-init_area");
                            }
                        }
                    }
                }
                PARAMETERS.HAND_MODE = isHand;
            }

            // 終了判定
            isGameOver = checkGameOver();
            if (isGameOver) return;

            // アシスト非表示
            if (isOnAssist) {
                onAssist(turn, false);
            }
            // ヒント非表示
            if (isOnHint) {
                onHint(false);
            }

            // 手番更新
            turn = nextTurn(turn);
            DOMTurn.textContent = COLOR_TEXT[turn];
            DOMTurn.dataset.color = COLOR_TEXT[turn].toLowerCase();

            // 番兵プレイヤー判定
            isSentinelTurn = checkSentinelTurn(turn);

            /*
            // 途中結果表示  // デバッグ用
            let result = "";
            for (let c = COLOR_ID.NONE; c <= PARAMETERS.COLOR_NUM; c++) {
                result += `${COLOR_TEXT[c]}: ${colorCount(c)}\n`;
            }
            DOMResult.textContent = result;
            */

            // パス判定
            if (isSentinelTurn) {  // 番兵プレイヤーならパス
                isPassed = true;
            } else {  // 着手可能な位置がないならパス
                isPassed = !checkCanPutAny(turn);
            }

            /*
            if (!isPassed) {
                // アシスト強制表示  // デバッグ用
                onAssist(turn, true);
                // ヒント強制表示  // デバッグ用
                onHint(true);
            }
            */

            if (isPassed) {
                if (!isSentinelTurn) {  // 番兵プレイヤーなら何もしない
                    DOMMessage.textContent = `Cannot put ${COLOR_TEXT[turn]} any position. ${COLOR_TEXT[turn]} is passed.\n`;
                    console.log(`turn: ${COLOR_TEXT[turn]}, pass`);  // ログ用
                    // 無効化
                    DOMAssist.disabled = true;
                    DOMHint.disabled = true;
                    // console.time("wait");  // デバッグ用
                    await wait(PARAMETERS.DELAY_MSEC);
                    // console.groupEnd("wait");  // デバッグ用
                    // 有効化
                    DOMAssist.disabled = false;
                    DOMHint.disabled = false;
                }
                await changeTurn();
                await AIListPut();
            }

            // console.groupEnd("changeTurn");  // デバッグ用
        }

        /** 番兵プレイヤー判定
        * @param {number} [color=turn] 手番
        * @returns {boolean} 番兵プレイヤーかどうか
        */
        function checkSentinelTurn(color = turn) {
            // console.group("checkSentinelTurn");  // デバッグ用

            // console.groupEnd("checkSentinelTurn");  // デバッグ用
            return isOnlyAI && !PARAMETERS.AI_LIST.includes(color);
        }

        /** 次の手番
        * @param {number} [color=turn] 手番
        * @returns {number} 次の手番
        */
        function nextTurn(color = turn) {
            // console.group("nextTurn");  // デバッグ用

            // console.groupEnd("nextTurn");  // デバッグ用
            return color % PARAMETERS.COLOR_NUM + 1;
        }

        /** 前の手番
        * @param {number} [color=turn] 手番
        * @returns {number} 前の手番
        */
        function prevTurn(color = turn) {
            // console.group("prevTurn");  // デバッグ用

            // console.groupEnd("prevTurn");  // デバッグ用
            return (color-2+PARAMETERS.COLOR_NUM) % PARAMETERS.COLOR_NUM + 1;
        }

        /** 指定色の個数をカウント
        * @param {number} [color=turn] 手番
        * @returns {number} 個数
        */
        function colorCount(color = turn) {
            // console.group("colorCount");  // デバッグ用

            let count = 0;
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    if (board[y][x] === color) {
                        count += weightBoard[y][x];
                    }
                }
            }

            // console.groupEnd("colorCount");  // デバッグ用

            return count
        }

        /** 終了判定, 勝敗判定
        * @returns {boolean} 終了かどうか
        */
        function checkGameOver() {
            // console.group("checkGameOver");  // デバッグ用

            let colorNum = PARAMETERS.COLOR_NUM;

            // 全員パスかどうか判定
            for (let c = COLOR_ID.NONE+1; c <= colorNum; c++) {
                if (checkCanPutAny(c)) return false;  // 続行
            }

            // 各色の個数をカウント
            const colorCounts = new Array(colorNum+1).fill(0);
            for (let c = COLOR_ID.NONE; c <= colorNum; c++) {
                colorCounts[c] = colorCount(c);
            }

            // 結果表示
            let result = "";
            let isEqAll = true;  // すべて同個数かどうか
            let maxCount = 0;  // 最大個数
            let maxColor = COLOR_ID.NONE;  // 最大個数手番
            if (isOnlyAI) {
                colorNum--;
            }
            for (let c = COLOR_ID.NONE+1; c <= colorNum; c++) {
                result += `${COLOR_TEXT[c]}=${colorCounts[c]}, `;
                if (c < colorNum && colorCounts[c] !== colorCounts[c+1]) {
                    isEqAll = false;
                }
                if (maxCount < colorCounts[c]) {
                    maxCount = colorCounts[c];
                    maxColor = c;
                }
            }
            if (isEqAll) {  // すべて同個数なら引き分け
                result += "draw.";
            } else {  // 最大個数が勝ち
                result += `${COLOR_TEXT[maxColor]} won.`;
            }
            // DOMTurn.textContent = "";
            DOMMessage.textContent = "This game was over.";
            DOMResult.textContent = result;
            DOMRecord.textContent = record;
            DOMTurn.classList.replace("shown", "hidden");
            DOMMessage.classList.replace("hidden", "shown");
            DOMResult.classList.replace("hidden", "shown");
            DOMRecord.classList.replace("hidden", "shown");

            // ハイライト非表示
            onHighlightAllHide();
            // アシスト非表示
            onAssist(turn, false);
            // ヒント非表示
            onHint(false);
            // 無効化
            DOMAssist.disabled = true;
            DOMHint.disabled = true;

            // setTimeout(() => alert("This game was over."), 1);  // アラート用
            console.log("This game was over.");  // ログ用
            console.log(`COLOR_NUM: ${PARAMETERS.COLOR_NUM}`);  // ログ用
            console.log(`BOARD_WIDTH: ${PARAMETERS.BOARD_WIDTH}`);  // ログ用
            console.log(`BOARD_HEIGHT: ${PARAMETERS.BOARD_HEIGHT}`);  // ログ用
            console.log(`AI_LIST: ${(PARAMETERS.AI_LIST.length === 0) ?COLOR_TEXT[0] :PARAMETERS.AI_LIST.map((i) => COLOR_TEXT[i])}`);  // ログ用
            console.log(`AI_LEVEL: ${(PARAMETERS.AI_LIST.length === 0) ?COLOR_TEXT[0] :PARAMETERS.AI_LEVEL}`);  // ログ用
            console.log(`DELAY_MSEC: ${PARAMETERS.DELAY_MSEC}ms`);  // ログ用
            console.log(`LUCKY_MODE: ${PARAMETERS.LUCKY_MODE}`);  // ログ用
            console.log(`HAND_MODE: ${PARAMETERS.HAND_MODE}`);  // ログ用
            console.log(`result:\n${result}`);  // ログ用
            console.log(`record: ${record}`);  // ログ用

            // console.groupEnd("checkGameOver");  // デバッグ用

            return true;  // 終了
        }

        /** 指定ミリ秒停止, AIの思考時間の視覚化
        * @param {number} delayMsec 停止時間[ms]
        */
        function wait(delayMsec) {
            // console.group("wait");  // デバッグ用

            // 停止しない
            if (delayMsec <= 0) {
                return new Promise((resolve) => {
                    // console.groupEnd("wait");  // デバッグ用
                    resolve();
                });
            }

            // プレイヤーのパスなら長くする
            if (!isAITurn) {
                const ext = 2;
                delayMsec *= ext;
            }

            const DOMProgress = DOMWait.querySelector("progress#progress");
            const DOMLabel = DOMWait.querySelector('label[for="progress"]');
            const DOMOutput = DOMWait.querySelector('output[for="progress"]');

            let progress = 0;  // AIの思考の進捗
            DOMLabel.textContent = (isAITurn && !isPassed) ?"AI thinking ..." :"Please wait ...";
            DOMProgress.value = `${progress}`;
            DOMProgress.textContent = `${progress}%`;
            DOMOutput.textContent = `${progress}%`;
            DOMWait.classList.replace("hidden", "shown");

            let intervalMsec = Math.max(delayMsec/Number(DOMProgress.max), 4);
            let intervalStep = Math.trunc(Number(DOMProgress.max)/(delayMsec/intervalMsec));

            return new Promise((resolve) => {
                // console.time("setInterval");  // デバッグ用
                intervalID = setInterval(() => {
                    // console.timeLog("setInterval");  // デバッグ用
                    progress += intervalStep;
                    DOMProgress.value = `${progress}`;
                    DOMProgress.textContent = `${progress}%`;
                    DOMOutput.textContent = `${progress}%`;
                    // console.log({progress});  // デバッグ用
                    if (progress >= Number(DOMProgress.max)) {
                        // console.groupEnd("wait");  // デバッグ用
                        // console.log({resolve});  // デバッグ用
                        DOMWait.classList.replace("shown", "hidden");
                        clearInterval(intervalID);
                        // console.timeEnd("setInterval");  // デバッグ用
                        resolve();
                    }
                }, intervalMsec);
            });
        }

        /** AIList着手 */
        async function AIListPut() {
            // console.group("AIListPut");  // デバッグ用

            for (const _ of PARAMETERS.AI_LIST) {
                await AIPut();
            }

            // console.groupEnd("AIListPut");  // デバッグ用
        }

        /** AI着手 */
        async function AIPut() {
            // console.group("AIPut");  // デバッグ用

            if (!PARAMETERS.AI_LIST.includes(turn)) return;
            if (isGameOver) return;

            isAITurn = true;
            // 無効化
            DOMAssist.disabled = true;
            DOMHint.disabled = true;
            // console.time("wait");  // デバッグ用
            await wait(PARAMETERS.DELAY_MSEC);
            // console.timeEnd("wait");  // デバッグ用
            // console.time("AIThink");  // デバッグ用
            const [AIx, AIy] = AIThink(PARAMETERS.AI_LEVEL);
            // console.timeEnd("AIThink");  // デバッグ用
            checkCanPut(AIx, AIy, turn, true);
            DOMMessage.textContent = "";
            isAITurn = false;
            // 有効化
            DOMAssist.disabled = false;
            DOMHint.disabled = false;

            await changeTurn();

            // console.groupEnd("AIPut");  // デバッグ用
        }

        /** AI思考
        * @param {number} [level=0] AI思考レベル
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink(level = 0) {
            // console.group("AIThink");  // デバッグ用

            /*
            // 最短5連続パス, プレイヤーにパスさせるデバッグ用
            // 8x8, black プレイヤー is 5パス
            if (checkCanPut(6, 8, COLOR_ID.WHITE, true)) return [6, 8];
            if (checkCanPut(4, 8, COLOR_ID.WHITE, true)) return [4, 8];
            if (checkCanPut(3, 7, COLOR_ID.WHITE, true)) return [3, 7];
            if (checkCanPut(8, 4, COLOR_ID.WHITE, true)) return [8, 4];
            */

            switch (level) {
                case 0: return AIThink0();
                case 1: return AIThink1();
                case 2: return AIThink2();
                case 3: return AIThink3();
                case 4: return AIThink4();
                case 5: return AIThink5();
                default: exit();
            }

            // console.groupEnd("AIThink");  // デバッグ用
        }

        /** AI思考レベル0
        * @description 着手可能な位置のうち(左上から)最初に見つけた位置に着手する
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink0() {
            // console.group("AIThink0");  // デバッグ用

            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    if (checkCanPut(x, y)) return [x, y];
                }
            }

            // console.groupEnd("AIThink0");  // デバッグ用
        }

        /** AI思考レベル1
        * @description 着手可能な位置のうち無作為に選ばれた位置に着手する
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink1() {
            // console.group("AIThink1");  // デバッグ用

            let canPutXYList = [];  // 着手位置の候補リスト
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    if (!checkCanPut(x, y)) continue;
                    canPutXYList.push([x, y]);
                }
            }
            // console.log(canPutXYList);  // デバッグ用
            // console.groupEnd("AIThink1");  // デバッグ用

            return canPutXYList[randomInt(canPutXYList.length)];
        }

        /** AI思考レベル2
        * @description 着手可能なうち反転可能個数が最大な位置に着手する(その位置が複数あるなら無作為に選択する)
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink2() {
            // console.group("AIThink2");  // デバッグ用

            let canPutCountFlipMax = 1;  // 着手可能なうちの最大反転個数
            let canPutXYList = [];  // 着手位置の候補リスト
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    let canPutCountFlip = checkCanPut(x, y);
                    if (canPutCountFlipMax <= canPutCountFlip) {
                        if (canPutCountFlipMax < canPutCountFlip) {
                            canPutXYList = [];
                        }
                        canPutCountFlipMax = canPutCountFlip;
                        canPutXYList.push([x, y]);
                    }
                }
            }
            // console.log(canPutXYList);  // デバッグ用
            // console.groupEnd("AIThink2");  // デバッグ用

            return canPutXYList[randomInt(canPutXYList.length)];
        }

        /** AI思考レベル3
        * @description 着手可能な位置で評価値が最大の位置に着手する(その位置が複数ある場合は無作為に選ぶ)
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink3() {
            // console.group("AIThink3");  // デバッグ用

            let canPutScoreMax = scoreBoard[0][0]-1;  // 着手可能な位置の最大評価値
            let canPutXYList = [];  // 着手位置の候補リスト
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    if (checkCanPut(x, y) && canPutScoreMax <= scoreBoard[y][x]) {
                        if (canPutScoreMax < scoreBoard[y][x]) {
                            canPutXYList = [];
                        }
                        canPutScoreMax = scoreBoard[y][x];
                        canPutXYList.push([x, y]);
                    }
                }
            }
            // console.log(canPutXYList);  // デバッグ用
            // console.groupEnd("AIThink3");  // デバッグ用

            return canPutXYList[randomInt(canPutXYList.length)];
        }

        /** AI思考レベル4
        * @description 次の手番の着手可能な位置の評価値の最大値が最小になる位置に着手する(その位置が複数ある場合は無作為に選ぶ)
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink4() {
            // console.group("AIThink4");  // デバッグ用

            let nextCanPutScoreMaxMin = scoreBoard[1][1]+1;  // 次の手番の着手可能な位置の評価値の最大値の最小値
            let canPutXYList = [];  // 着手位置の候補リスト
            for (let y = 1; y <= PARAMETERS.BOARD_HEIGHT; y++) {
                for (let x = 1; x <= PARAMETERS.BOARD_WIDTH; x++) {
                    virtualBoard = structuredClone(board);
                    if (!checkCanPut(x, y, turn, true, false)) continue;
                    // console.log(`x=${x}, y=${y}, score=${scoreBoard[y][x]}`);  // デバッグ用

                    let nextCanPutScoreMax = scoreBoard[0][0]-1;  // 次の手番の着手可能な位置の評価値の最大値
                    for (let nextY = 1; nextY <= PARAMETERS.BOARD_HEIGHT; nextY++) {
                        for (let nextX = 1; nextX <= PARAMETERS.BOARD_WIDTH; nextX++) {
                            if (!checkCanPut(nextX, nextY, nextTurn(turn), false, false)) continue;
                            nextCanPutScoreMax = Math.max(nextCanPutScoreMax, scoreBoard[nextY][nextX]);
                            // console.group("nextX=", nextX, "nextY=", nextY, "score=", scoreBoard[nextY][nextX]);  // デバッグ用
                        }
                    }

                    if (nextCanPutScoreMaxMin >= nextCanPutScoreMax) {
                        if (nextCanPutScoreMaxMin > nextCanPutScoreMax) {
                            canPutXYList = [];
                        }
                        nextCanPutScoreMaxMin = nextCanPutScoreMax;
                        canPutXYList.push([x, y]);
                    }
                }
            }
            // console.log(canPutXYList);  // デバッグ用
            // return canPutXYList[randomInt(canPutXYList.length)];

            let canPutScoreMax = scoreBoard[0][0];  // 着手位置の候補リストのうち自手番の評価値の最大値
            let canPutScoreMaxXYList = [];  // 着手位置の候補リストのうち自手番の評価値が最大になる位置のリスト
            for (const [x, y] of canPutXYList) {
                if (canPutScoreMax <= scoreBoard[y][x]) {
                    if (canPutScoreMax < scoreBoard[y][x]) {
                        canPutScoreMaxXYList = [];
                    }
                    canPutScoreMax = scoreBoard[y][x];
                    canPutScoreMaxXYList.push([x, y]);
                }
            }
            // console.log(canPutScoreMaxXYList);  // デバッグ用
            // console.groupEnd("AIThink4");  // デバッグ用

            return canPutScoreMaxXYList[randomInt(canPutScoreMaxXYList.length)];
        }

        /** AI思考レベル5
        * @description 試合進捗によってAI思考レベルを変動させる
        * @returns {number[]} 盤面のx座標とy座標の組
        */
        function AIThink5() {
            // console.group("AIThink5");  // デバッグ用

            // console.groupEnd("AIThink5");  // デバッグ用

            const PHASE_NUM = 4;
            if (gameProgress < Math.trunc(GAME_PROGRESS_MAX/PHASE_NUM)) {  // 序盤
                // console.group("序盤");  // デバッグ用
                return AIThink3();
            } else if (gameProgress < Math.trunc(GAME_PROGRESS_MAX*2/PHASE_NUM)) {  // 中盤1
                // console.group("中盤1");  // デバッグ用
                return AIThink3();
            } else if (gameProgress < Math.trunc(GAME_PROGRESS_MAX*3/PHASE_NUM)) {  // 中盤2
                // console.group("中盤2");  // デバッグ用
                return AIThink4();
            } else {  // 終盤
                // console.group("終盤");  // デバッグ用
                return AIThink2();
            }
        }
        });
    </script>
  </body>
</html>
